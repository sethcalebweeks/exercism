THERE_BE_DRAGONS_HERE
#Raindrops is missing, and does not understand #new
31 May 2023 6:32:57.89553 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(Raindrops)
		aMessage: 	new
		exception: 	#Raindrops is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RaindropsTest>>setUp
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	nil


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:32:57.661099-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:32:57.661099-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	nil


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(630051328)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
RaindropsTest>>setUp
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#Raindrops is missing, and does not understand #new
31 May 2023 6:32:58.105764 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(Raindrops)
		aMessage: 	new
		exception: 	#Raindrops is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RaindropsTest>>setUp
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	nil


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:32:57.661099-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:32:57.661099-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	nil


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(630051328)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
RaindropsTest>>setUp
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Raindrops did not understand #convertNumber:
31 May 2023 6:33:23.150155 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Raindrops(Object)>>doesNotUnderstand: #convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		aMessage: 	convertNumber: 1
		exception: 	Instance of Raindrops did not understand #convertNumber:
		resumeValue: 	nil
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:32:57.661099-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1 RaindropsTe...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:32:57.661099-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1 RaindropsTe...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(630051328)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
Raindrops(Object)>>doesNotUnderstand: #convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Raindrops did not understand #convertNumber:
31 May 2023 6:33:23.303368 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Raindrops(Object)>>doesNotUnderstand: #convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		aMessage: 	convertNumber: 1
		exception: 	Instance of Raindrops did not understand #convertNumber:
		resumeValue: 	nil
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:32:57.661099-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1 RaindropsTe...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:32:57.661099-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1 RaindropsTe...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(630051328)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
Raindrops(Object)>>doesNotUnderstand: #convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '1' instead of 'Pling'.
31 May 2023 6:35:07.910938 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''1'' instead of ''Pling''.'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		actual: 	'1'
		expected: 	'Pling'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:35:07.897042-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:35:07.897042-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(630051328)
		selectedItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '1' instead of 'Pling'.
31 May 2023 6:35:08.066702 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''1'' instead of ''Pling''.'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		actual: 	'1'
		expected: 	'Pling'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:35:07.897042-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:35:07.897042-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(630051328)
		selectedItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMoTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #toString
31 May 2023 6:37:32.740308 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #toString
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	Instance of SmallInteger did not understand #toString
		resumeValue: 	nil
	Receiver's instance variables: 
1

Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:37:32.701544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:37:32.701544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #toString
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #toString
31 May 2023 6:37:32.866548 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #toString
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	Instance of SmallInteger did not understand #toString
		resumeValue: 	nil
	Receiver's instance variables: 
1

Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:37:32.701544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:37:32.701544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #toString
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #toString
31 May 2023 6:37:48.943016 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #toString
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	Instance of SmallInteger did not understand #toString
		resumeValue: 	nil
	Receiver's instance variables: 
1

Raindrops>>DoItIn:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		ThisContext: 	Raindrops>>convertNumber:
	Receiver's instance variables: 
a Raindrops

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext

	^ (ThisContext readVariableNamed: 'anInteger') toStr...etc...
		source: 	a ReadStream
		context: 	Raindrops>>convertNumber:
		receiver: 	a Raindrops
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext

	^ (ThisContext readVariableNamed: 'anInteger') toStr...etc...
		source: 	a ReadStream
		context: 	Raindrops>>convertNumber:
		receiver: 	a Raindrops
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'	^ anInteger toString '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	a Raindrops
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StDebugger
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (27 to: 48) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'convertNumber: anInteger 
	^ anInteger toStrin...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ a SpMenuPresenter ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StDebuggerContextInteractionModel...etc...
		overrideContextMenu: 	false
		submitBlock: 	[ :text | 
		self acceptCodeChanges: text string forContext: self ...etc...
		resetBlock: 	[ self discardCodeChangesFor: self selectedContext ]
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	a Raindrops
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'	^ anInteger toString '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StDebugger
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (27 to: 48) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'convertNumber: anInteger 
	^ anInteger toStrin...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ a SpMenuPresenter ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StDebuggerContextInteractionModel...etc...
		overrideContextMenu: 	false
		submitBlock: 	[ :text | 
		self acceptCodeChanges: text string forContext: self ...etc...
		resetBlock: 	[ self discardCodeChangesFor: self selectedContext ]
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aString: 	'	^ anInteger toString '
		aBlock: 	[ :result | 
		self inspectObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self inspectObject: result ]
		selection: 	'	^ anInteger toString '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand>>execute
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Inspect it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeInspectItCommand
		iconProvider: 	a ThemeIcons(idea11)
		iconName: 	#smallInspectIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
	Receiver: a SpMenuPresenterBuilder
	Arguments and temporary variables: 
		aMenuItem: 	a SpMenuItemPresenter
		aCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		menuPresenter: 	a SpMenuPresenter
		stack: 	a Stack(a SpMenuPresenter)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ aCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		outerContext: 	SpMenuPresenterBuilder>>fillItem:with:
		startpc: 	a CompiledBlock: [ aCommand execute ]
		numArgs: 	0
		receiver: 	a SpMenuPresenterBuilder


SpMenuItemPresenter>>performMenuActionWith:
	Receiver: a SpMenuItemPresenter
	Arguments and temporary variables: 
		aMenuItem: 	a SpMorphicMenuItemAdapter
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicMenuItemAdapter)
		announcer: 	an Announcer
		owner: 	a SpMenuGroupPresenter
		adapter: 	a SpMorphicMenuItemAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		name: 	an ObservableValueHolder[ 'Inspect it' ]
		icon: 	an ObservableValueHolder[ Form(16x16x32) ]
		description: 	an ObservableValueHolder[ 'Evaluate selection and inspect the resu...etc...
		action: 	[ aCommand execute ]
		shortcut: 	a KMKeyCombinationChoice
		subMenu: 	nil
		state: 	nil


SpMorphicMenuItemAdapter>>performMenuActionWith:
	Receiver: a SpMorphicMenuItemAdapter
	Arguments and temporary variables: 
		arguments: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		model: 	a SpMenuItemPresenter
		widget: 	a SpToggleMenuItemMorph(716397056)'Inspect it'
		selector: 	nil
		owner: 	a SpMenuItemPresenter
		unsubscribed: 	false


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(716397056)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(205@296) mouseUp 401679 nil]
		w: 	a WorldMorph(810529024) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(159.0@289.0) corner: (316.0@307.0)
		owner: 	a MenuMorph(787134976)
		submorphs: 	#()
		fullBounds: 	(159.0@289.0) corner: (316.0@307.0)
		color: 	Color black
		extension: 	a MorphExtension (861906944) [balloonText]  [other:  (presenter -> a...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'Ctrl+I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a SpToggleMenuItemMorph(716397056)'Inspect it'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(716397056)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(205@296) mouseUp 401679 nil]
		w: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(159.0@289.0) corner: (316.0@307.0)
		owner: 	a MenuMorph(787134976)
		submorphs: 	#()
		fullBounds: 	(159.0@289.0) corner: (316.0@307.0)
		color: 	Color black
		extension: 	a MorphExtension (861906944) [balloonText]  [other:  (presenter -> a...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'Ctrl+I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a SpToggleMenuItemMorph(716397056)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(205@296) mouseUp 401679 nil]
	Receiver's instance variables: 
		bounds: 	(159.0@289.0) corner: (316.0@307.0)
		owner: 	a MenuMorph(787134976)
		submorphs: 	#()
		fullBounds: 	(159.0@289.0) corner: (316.0@307.0)
		color: 	Color black
		extension: 	a MorphExtension (861906944) [balloonText]  [other:  (presenter -> a...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'Ctrl+I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a SpToggleMenuItemMorph(716397056)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(205@296) mouseUp 401679 nil]
	Receiver's instance variables: 
		bounds: 	(159.0@289.0) corner: (316.0@307.0)
		owner: 	a MenuMorph(787134976)
		submorphs: 	#()
		fullBounds: 	(159.0@289.0) corner: (316.0@307.0)
		color: 	Color black
		extension: 	a MorphExtension (861906944) [balloonText]  [other:  (presenter -> a...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'Ctrl+I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MouseButtonEvent>>sentTo:
	Receiver: [(205@296) mouseUp 401679 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToggleMenuItemMorph(716397056)'Inspect it'
	Receiver's instance variables: 
		timeStamp: 	401679
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(205@296)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a SpToggleMenuItemMorph(716397056)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(205@296) mouseUp 401679 nil]
	Receiver's instance variables: 
		bounds: 	(159.0@289.0) corner: (316.0@307.0)
		owner: 	a MenuMorph(787134976)
		submorphs: 	#()
		fullBounds: 	(159.0@289.0) corner: (316.0@307.0)
		color: 	Color black
		extension: 	a MorphExtension (861906944) [balloonText]  [other:  (presenter -> a...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'Ctrl+I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(205@296) mouseUp 401679 nil]
		aMorph: 	a SpToggleMenuItemMorph(716397056)'Inspect it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(716397056)'Inspect it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(205@296) mouseUp 401679 nil]
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(716397056)'Inspect it'


MouseButtonEvent>>sentTo:
	Receiver: [(205@296) mouseUp 401679 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	401679
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(205@296)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #toString
Raindrops>>DoItIn:
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeInspectItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpRubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #toString
31 May 2023 6:37:49.168162 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #toString
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	Instance of SmallInteger did not understand #toString
		resumeValue: 	nil
	Receiver's instance variables: 
1

Raindrops>>DoItIn:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		ThisContext: 	Raindrops>>convertNumber:
	Receiver's instance variables: 
a Raindrops

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext

	^ (ThisContext readVariableNamed: 'anInteger') toStr...etc...
		source: 	a ReadStream
		context: 	Raindrops>>convertNumber:
		receiver: 	a Raindrops
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext

	^ (ThisContext readVariableNamed: 'anInteger') toStr...etc...
		source: 	a ReadStream
		context: 	Raindrops>>convertNumber:
		receiver: 	a Raindrops
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'	^ anInteger toString '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	a Raindrops
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StDebugger
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (27 to: 48) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'convertNumber: anInteger 
	^ anInteger toStrin...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ a SpMenuPresenter ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StDebuggerContextInteractionModel...etc...
		overrideContextMenu: 	false
		submitBlock: 	[ :text | 
		self acceptCodeChanges: text string forContext: self ...etc...
		resetBlock: 	[ self discardCodeChangesFor: self selectedContext ]
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	a Raindrops
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'	^ anInteger toString '
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StDebugger
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (27 to: 48) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'convertNumber: anInteger 
	^ anInteger toStrin...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ a SpMenuPresenter ]
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StDebuggerContextInteractionModel...etc...
		overrideContextMenu: 	false
		submitBlock: 	[ :text | 
		self acceptCodeChanges: text string forContext: self ...etc...
		resetBlock: 	[ self discardCodeChangesFor: self selectedContext ]
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aString: 	'	^ anInteger toString '
		aBlock: 	[ :result | 
		self inspectObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self inspectObject: result ]
		selection: 	'	^ anInteger toString '
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCodeInspectItCommand>>execute
	Receiver: a SpCodeInspectItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Inspect it'
		basicDescription: 	'Evaluate selection and inspect the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Inspect it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodeInspectItCommand
		iconProvider: 	a ThemeIcons(idea11)
		iconName: 	#smallInspectIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Inspect it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
	Receiver: a SpMenuPresenterBuilder
	Arguments and temporary variables: 
		aMenuItem: 	a SpMenuItemPresenter
		aCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		menuPresenter: 	a SpMenuPresenter
		stack: 	a Stack(a SpMenuPresenter)


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ aCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		outerContext: 	SpMenuPresenterBuilder>>fillItem:with:
		startpc: 	a CompiledBlock: [ aCommand execute ]
		numArgs: 	0
		receiver: 	a SpMenuPresenterBuilder


SpMenuItemPresenter>>performMenuActionWith:
	Receiver: a SpMenuItemPresenter
	Arguments and temporary variables: 
		aMenuItem: 	a SpMorphicMenuItemAdapter
		en: 	true
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicMenuItemAdapter)
		announcer: 	an Announcer
		owner: 	a SpMenuGroupPresenter
		adapter: 	a SpMorphicMenuItemAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		name: 	an ObservableValueHolder[ 'Inspect it' ]
		icon: 	an ObservableValueHolder[ Form(16x16x32) ]
		description: 	an ObservableValueHolder[ 'Evaluate selection and inspect the resu...etc...
		action: 	[ aCommand execute ]
		shortcut: 	a KMKeyCombinationChoice
		subMenu: 	nil
		state: 	nil


SpMorphicMenuItemAdapter>>performMenuActionWith:
	Receiver: a SpMorphicMenuItemAdapter
	Arguments and temporary variables: 
		arguments: 	a SpMorphicMenuItemAdapter
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		model: 	a SpMenuItemPresenter
		widget: 	a SpToggleMenuItemMorph(716397056)'Inspect it'
		selector: 	nil
		owner: 	a SpMenuItemPresenter
		unsubscribed: 	false


[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(716397056)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(205@296) mouseUp 401679 nil]
		w: 	a WorldMorph(810529024) [world]
		selArgCount: 	1
	Receiver's instance variables: 
		bounds: 	(159.0@289.0) corner: (316.0@307.0)
		owner: 	a MenuMorph(787134976)
		submorphs: 	#()
		fullBounds: 	(159.0@289.0) corner: (316.0@307.0)
		color: 	Color black
		extension: 	a MorphExtension (861906944) [balloonText]  [other:  (presenter -> a...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'Ctrl+I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := sel...etc...
	Arguments and temporary variables: 
		aBlock: 	[oldcursor show]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
		startpc: 	a CompiledBlock: [ | selArgCount |  "show cursor in case item opens a ...etc...
		numArgs: 	0
		receiver: 	a SpToggleMenuItemMorph(716397056)'Inspect it'


CursorWithMask(Cursor)>>showWhile:
	Receiver: ((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2r100000000000000000000...etc...
	Arguments and temporary variables: 
		aBlock: 	[ | selArgCount |  "show cursor in case item opens a new MVC window"
		...etc...
		oldcursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0
		2...etc...
	Receiver's instance variables: 
		bits: 	a Bitmap of length 16
		width: 	16
		height: 	16
		depth: 	1
		offset: 	(-1@ -1)
		maskForm: 	Form(16x16x1)


SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
	Receiver: a SpToggleMenuItemMorph(716397056)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(205@296) mouseUp 401679 nil]
		w: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(159.0@289.0) corner: (316.0@307.0)
		owner: 	a MenuMorph(787134976)
		submorphs: 	#()
		fullBounds: 	(159.0@289.0) corner: (316.0@307.0)
		color: 	Color black
		extension: 	a MorphExtension (861906944) [balloonText]  [other:  (presenter -> a...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'Ctrl+I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
	Receiver: a SpToggleMenuItemMorph(716397056)'Inspect it'
	Arguments and temporary variables: 
		evt: 	[(205@296) mouseUp 401679 nil]
	Receiver's instance variables: 
		bounds: 	(159.0@289.0) corner: (316.0@307.0)
		owner: 	a MenuMorph(787134976)
		submorphs: 	#()
		fullBounds: 	(159.0@289.0) corner: (316.0@307.0)
		color: 	Color black
		extension: 	a MorphExtension (861906944) [balloonText]  [other:  (presenter -> a...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'Ctrl+I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
	Receiver: a SpToggleMenuItemMorph(716397056)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(205@296) mouseUp 401679 nil]
	Receiver's instance variables: 
		bounds: 	(159.0@289.0) corner: (316.0@307.0)
		owner: 	a MenuMorph(787134976)
		submorphs: 	#()
		fullBounds: 	(159.0@289.0) corner: (316.0@307.0)
		color: 	Color black
		extension: 	a MorphExtension (861906944) [balloonText]  [other:  (presenter -> a...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'Ctrl+I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MouseButtonEvent>>sentTo:
	Receiver: [(205@296) mouseUp 401679 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToggleMenuItemMorph(716397056)'Inspect it'
	Receiver's instance variables: 
		timeStamp: 	401679
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(205@296)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToggleMenuItemMorph(Morph)>>handleEvent:
	Receiver: a SpToggleMenuItemMorph(716397056)'Inspect it'
	Arguments and temporary variables: 
		anEvent: 	[(205@296) mouseUp 401679 nil]
	Receiver's instance variables: 
		bounds: 	(159.0@289.0) corner: (316.0@307.0)
		owner: 	a MenuMorph(787134976)
		submorphs: 	#()
		fullBounds: 	(159.0@289.0) corner: (316.0@307.0)
		color: 	Color black
		extension: 	a MorphExtension (861906944) [balloonText]  [other:  (presenter -> a...etc...
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 1...etc...
		emphasis: 	0
		contents: 	'Inspect it'
		hasFocus: 	false
		backgroundColor: 	Color transparent
		isEnabled: 	true
		subMenu: 	nil
		isSelected: 	false
		target: 	a SpMorphicMenuItemAdapter
		selector: 	#performMenuActionWith:
		arguments: 	an Array(a SpMorphicMenuItemAdapter)
		icon: 	Form(16x16x32)
		keyText: 	'Ctrl+I'
		getStateSelector: 	nil
		enablementSelector: 	#enabled


MorphicEventDispatcher>>dispatchDefault:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(205@296) mouseUp 401679 nil]
		aMorph: 	a SpToggleMenuItemMorph(716397056)'Inspect it'
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		inside: 	true
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(716397056)'Inspect it'


MorphicEventDispatcher>>handleMouseUp:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(205@296) mouseUp 401679 nil]
	Receiver's instance variables: 
		morph: 	a SpToggleMenuItemMorph(716397056)'Inspect it'


MouseButtonEvent>>sentTo:
	Receiver: [(205@296) mouseUp 401679 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	401679
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(205@296)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #toString
Raindrops>>DoItIn:
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeInspectItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeInspectItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ aCommand execute ] in SpMenuPresenterBuilder>>fillItem:with:
FullBlockClosure(BlockClosure)>>cull:
SpMenuItemPresenter>>performMenuActionWith:
SpMorphicMenuItemAdapter>>performMenuActionWith:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
SpToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
SpToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
SpToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
MenuMorph>>invokeAt:in:allowKeyboard:
MenuMorph>>invokeAt:in:
MenuMorph>>invokeModal
RubEditingArea(RubAbstractTextArea)>>yellowButtonActivity:
RubEditingArea(RubAbstractTextArea)>>mouseDown:
RubEditingArea(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubEditingArea(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TransformWithLayoutMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
RubTextScrollPane(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpRubScrolledTextMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlocTHERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #toString
31 May 2023 6:38:47.402947 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #toString
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	Instance of SmallInteger did not understand #toString
		resumeValue: 	nil
	Receiver's instance variables: 
1

Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:38:47.373514-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:38:47.373514-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #toString
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #toString
31 May 2023 6:38:47.497284 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #toString
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	Instance of SmallInteger did not understand #toString
		resumeValue: 	nil
	Receiver's instance variables: 
1

Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:38:47.373514-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:38:47.373514-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #toString
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #toString
31 May 2023 6:39:25.306714 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #toString
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	Instance of SmallInteger did not understand #toString
		resumeValue: 	nil
	Receiver's instance variables: 
1

Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:39:25.283727-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:39:25.283727-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #toString
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #toString
31 May 2023 6:39:25.403386 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #toString
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	Instance of SmallInteger did not understand #toString
		resumeValue: 	nil
	Receiver's instance variables: 
1

Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:39:25.283727-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:39:25.283727-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #toString
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>perfoTHERE_BE_DRAGONS_HERE
TestFailure: Got '3' instead of 'Pling'.
31 May 2023 6:44:47.427064 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''3'' instead of ''Pling''.'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		actual: 	'3'
		expected: 	'Pling'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	'3'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:44:47.313781-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:44:47.313781-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '3' instead of 'Pling'.
31 May 2023 6:44:47.582569 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''3'' instead of ''Pling''.'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		actual: 	'3'
		expected: 	'Pling'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	'3'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:44:47.313781-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:44:47.313781-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	ReceiTHERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
31 May 2023 6:56:04.574982 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 1
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
1

SmallInteger(Object)>>errorNotIndexable
	Receiver: 1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1

SmallInteger(Object)>>size
	Receiver: 1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: ''
	Arguments and temporary variables: 
		start: 	1
		stop: 	0
		replacementCollection: 	1
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
''

ByteString(SequenceableCollection)>>,
	Receiver: ''
	Arguments and temporary variables: 
		otherCollection: 	1
	Receiver's instance variables: 
''

[:each | result , anInteger printStringBase: 10 ] in Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
		result: 	''
		each: 	'Pling'
	Receiver's instance variables: 
a Raindrops

Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:each | result , anInteger printStringBase: 10 ]
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:each | result , anInteger printStringBase: 10 ]
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
		result: 	''
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:56:04.512145-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:56:04.512145-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[:each | result , anInteger printStringBase: 10 ] in Raindrops>>convertNumber:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
31 May 2023 6:56:04.76616 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 1
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
1

SmallInteger(Object)>>errorNotIndexable
	Receiver: 1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1

SmallInteger(Object)>>size
	Receiver: 1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: ''
	Arguments and temporary variables: 
		start: 	1
		stop: 	0
		replacementCollection: 	1
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
''

ByteString(SequenceableCollection)>>,
	Receiver: ''
	Arguments and temporary variables: 
		otherCollection: 	1
	Receiver's instance variables: 
''

[:each | result , anInteger printStringBase: 10 ] in Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
		result: 	''
		each: 	'Pling'
	Receiver's instance variables: 
a Raindrops

Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:each | result , anInteger printStringBase: 10 ]
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:each | result , anInteger printStringBase: 10 ]
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
		result: 	''
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:56:04.512145-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:56:04.512145-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[:each | result , anInteger printStringBase: 10 ] in Raindrops>>convertNumber:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
31 May 2023 6:57:13.979688 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 1
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
1

SmallInteger(Object)>>errorNotIndexable
	Receiver: 1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1

SmallInteger(Object)>>size
	Receiver: 1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: ''
	Arguments and temporary variables: 
		start: 	1
		stop: 	0
		replacementCollection: 	1
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
''

ByteString(SequenceableCollection)>>,
	Receiver: ''
	Arguments and temporary variables: 
		otherCollection: 	1
	Receiver's instance variables: 
''

[:each | result , anInteger printStringBase: 10 ] in Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
		result: 	''
		each: 	3
	Receiver's instance variables: 
a Raindrops

Dictionary>>valuesDo:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:each | result , anInteger printStringBase: 10 ]
		eachIndex: 	2
		eachAssociation: 	'Pling'->3
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Dictionary>>do:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:each | result , anInteger printStringBase: 10 ]
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
		result: 	''
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:57:13.848283-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:57:13.848283-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[:each | result , anInteger printStringBase: 10 ] in Raindrops>>convertNumber:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
31 May 2023 6:57:14.153365 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 1
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
1

SmallInteger(Object)>>errorNotIndexable
	Receiver: 1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1

SmallInteger(Object)>>size
	Receiver: 1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: ''
	Arguments and temporary variables: 
		start: 	1
		stop: 	0
		replacementCollection: 	1
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
''

ByteString(SequenceableCollection)>>,
	Receiver: ''
	Arguments and temporary variables: 
		otherCollection: 	1
	Receiver's instance variables: 
''

[:each | result , anInteger printStringBase: 10 ] in Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
		result: 	''
		each: 	3
	Receiver's instance variables: 
a Raindrops

Dictionary>>valuesDo:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:each | result , anInteger printStringBase: 10 ]
		eachIndex: 	2
		eachAssociation: 	'Pling'->3
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Dictionary>>do:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:each | result , anInteger printStringBase: 10 ]
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
		result: 	''
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:57:13.848283-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:57:13.848283-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: <<error during printing>>

RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[:each | result , anInteger printStringBase: 10 ] in Raindrops>>convertNumber:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '' instead of '1'.
31 May 2023 6:58:12.069347 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got '''' instead of ''1''.'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		actual: 	''
		expected: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	''
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:58:12.016374-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:58:12.016374-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '' instead of '1'.
31 May 2023 6:58:12.221561 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got '''' instead of ''1''.'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		actual: 	''
		expected: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	''
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:58:12.016374-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:58:12.016374-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '' instead of '1'.
31 May 2023 6:58:42.973139 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got '''' instead of ''1''.'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		actual: 	''
		expected: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	''
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:58:42.946424-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:58:42.946424-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '' instead of '1'.
31 May 2023 6:58:43.067626 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got '''' instead of ''1''.'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		actual: 	''
		expected: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	''
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:58:42.946424-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T18:58:42.946424-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '111' instead of '1'.
31 May 2023 7:01:17.526859 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''111'' instead of ''1''.'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		actual: 	'111'
		expected: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	'111'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:01:17.461156-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:01:17.461156-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '111' instead of '1'.
31 May 2023 7:01:17.683857 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''111'' instead of ''1''.'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		actual: 	'111'
		expected: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	'111'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:01:17.461156-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:01:17.461156-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	<<error during printing>>

ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(418304000)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
31 May 2023 7:03:07.324412 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 3
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
3

SmallInteger(Object)>>errorNotIndexable
	Receiver: 3
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
3

SmallInteger(Object)>>size
	Receiver: 3
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
3

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: ''
	Arguments and temporary variables: 
		start: 	1
		stop: 	0
		replacementCollection: 	3
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
''

ByteString(SequenceableCollection)>>,
	Receiver: ''
	Arguments and temporary variables: 
		otherCollection: 	3
	Receiver's instance variables: 
''

[:sound | result := result , sound ] in Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
		result: 	''
		sound: 	3
	Receiver's instance variables: 
a Raindrops

Dictionary>>valuesDo:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:sound | result := result , sound ]
		eachIndex: 	2
		eachAssociation: 	'Pling'->3
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Dictionary>>do:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:sound | result := result , sound ]
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:03:07.220771-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:03:07.220771-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[:sound | result := result , sound ] in Raindrops>>convertNumber:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
31 May 2023 7:03:07.407158 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 3
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
3

SmallInteger(Object)>>errorNotIndexable
	Receiver: 3
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
3

SmallInteger(Object)>>size
	Receiver: 3
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
3

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: ''
	Arguments and temporary variables: 
		start: 	1
		stop: 	0
		replacementCollection: 	3
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
''

ByteString(SequenceableCollection)>>,
	Receiver: ''
	Arguments and temporary variables: 
		otherCollection: 	3
	Receiver's instance variables: 
''

[:sound | result := result , sound ] in Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
		result: 	''
		sound: 	3
	Receiver's instance variables: 
a Raindrops

Dictionary>>valuesDo:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:sound | result := result , sound ]
		eachIndex: 	2
		eachAssociation: 	'Pling'->3
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Dictionary>>do:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:sound | result := result , sound ]
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:03:07.220771-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:03:07.220771-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[:sound | result := result , sound ] in Raindrops>>convertNumber:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
31 May 2023 7:05:17.798504 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 3
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
3

SmallInteger(Object)>>errorNotIndexable
	Receiver: 3
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
3

SmallInteger(Object)>>size
	Receiver: 3
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
3

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: ''
	Arguments and temporary variables: 
		start: 	1
		stop: 	0
		replacementCollection: 	3
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
''

ByteString(SequenceableCollection)>>,
	Receiver: ''
	Arguments and temporary variables: 
		otherCollection: 	3
	Receiver's instance variables: 
''

[:sound | 
		Transcript show: sound .
		result := result , sound .
	] in Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
		result: 	''
		sound: 	3
	Receiver's instance variables: 
a Raindrops

Dictionary>>valuesDo:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:sound | 
		Transcript show: sound .
		result := result , sound .
	]
		eachIndex: 	2
		eachAssociation: 	'Pling'->3
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Dictionary>>do:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:sound | 
		Transcript show: sound .
		result := result , sound .
	]
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Receiver's instance variables: 
a Raindrops

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	r := Raindrops new.
	^ r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	r := Raindrops new.
	^ r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'r := Raindrops new .
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 39) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new .
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'r := Raindrops new .
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 39) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new .
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(168362496))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(168362496)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		event: 	[(17.0@13.0) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		evt: 	[(17.0@13.0) mouseUp 2050729 nil]
		all: 	an Array(a SpToolbarButtonMorph(168362496) a SpToolbarButtonMorph(95125606...etc...
		m: 	a SpToolbarButtonMorph(168362496)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(168362496) a SpToolbarButtonMorph(951256064) a SpToolbarBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(168362496) a SpToolbarButtonMorph(951256064) a SpToolbarBu...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		evt: 	[(17.0@13.0) mouseUp 2050729 nil]
		all: 	an Array(a SpToolbarButtonMorph(168362496) a SpToolbarButtonMorph(95125606...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		anEvent: 	[(17.0@13.0) mouseUp 2050729 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(17.0@13.0) mouseUp 2050729 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(168362496)
	Receiver's instance variables: 
		timeStamp: 	2050729
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(17.0@13.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		anEvent: 	[(17.0@13.0) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		anEvent: 	[(17.0@13.0) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@309) mouseUp 2050729 nil]
		focusHolder: 	a SpToolbarButtonMorph(168362496)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(17.0@13.0) mouseUp 2050729 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(529@309.0) corner: (545@325.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@309.0) corner: (545@325.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(793701888)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@309) mouseUp 2050729 nil]
		targetOffset: 	(17.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(1015088640)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(529@309) mouseUp 2050729 nil]
		focusHolder: 	a SpToolbarButtonMorph(168362496)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(17.0@13.0) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(529@309.0) corner: (545@325.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@309.0) corner: (545@325.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(793701888)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@309) mouseUp 2050729 nil]
		targetOffset: 	(17.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@309) mouseUp 2050729 nil]
		focusHolder: 	a SpToolbarButtonMorph(168362496)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(529@309.0) corner: (545@325.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@309.0) corner: (545@325.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(793701888)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@309) mouseUp 2050729 nil]
		targetOffset: 	(17.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@309) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(529@309.0) corner: (545@325.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@309.0) corner: (545@325.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(793701888)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@309) mouseUp 2050729 nil]
		targetOffset: 	(17.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@309) mouseUp 2050729 nil]
		evt: 	[(529@309) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(529@309.0) corner: (545@325.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@309.0) corner: (545@325.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(793701888)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@309) mouseUp 2050729 nil]
		targetOffset: 	(17.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(529@309) mouseUp 2050729 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[:sound | 
		Transcript show: sound .
		result := result , sound .
	] in Raindrops>>convertNumber:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
31 May 2023 7:05:17.938459 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 3
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
3

SmallInteger(Object)>>errorNotIndexable
	Receiver: 3
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
3

SmallInteger(Object)>>size
	Receiver: 3
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
3

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: ''
	Arguments and temporary variables: 
		start: 	1
		stop: 	0
		replacementCollection: 	3
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
''

ByteString(SequenceableCollection)>>,
	Receiver: ''
	Arguments and temporary variables: 
		otherCollection: 	3
	Receiver's instance variables: 
''

[:sound | 
		Transcript show: sound .
		result := result , sound .
	] in Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
		result: 	''
		sound: 	3
	Receiver's instance variables: 
a Raindrops

Dictionary>>valuesDo:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:sound | 
		Transcript show: sound .
		result := result , sound .
	]
		eachIndex: 	2
		eachAssociation: 	'Pling'->3
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Dictionary>>do:
	Receiver: a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Arguments and temporary variables: 
		aBlock: 	[:sound | 
		Transcript show: sound .
		result := result , sound .
	]
	Receiver's instance variables: 
		tally: 	3
		array: 	{nil. 'Pling'->3. 'Plong'->7. 'Plang'->5. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	1
		sounds: 	a Dictionary('Plang'->5 'Pling'->3 'Plong'->7 )
	Receiver's instance variables: 
a Raindrops

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	r := Raindrops new.
	^ r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	r := Raindrops new.
	^ r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'r := Raindrops new .
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 39) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new .
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'r := Raindrops new .
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 39) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new .
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(168362496))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(168362496)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		event: 	[(17.0@13.0) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		evt: 	[(17.0@13.0) mouseUp 2050729 nil]
		all: 	an Array(a SpToolbarButtonMorph(168362496) a SpToolbarButtonMorph(95125606...etc...
		m: 	a SpToolbarButtonMorph(168362496)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(168362496) a SpToolbarButtonMorph(951256064) a SpToolbarBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(168362496) a SpToolbarButtonMorph(951256064) a SpToolbarBu...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		evt: 	[(17.0@13.0) mouseUp 2050729 nil]
		all: 	an Array(a SpToolbarButtonMorph(168362496) a SpToolbarButtonMorph(95125606...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		anEvent: 	[(17.0@13.0) mouseUp 2050729 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(17.0@13.0) mouseUp 2050729 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(168362496)
	Receiver's instance variables: 
		timeStamp: 	2050729
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(17.0@13.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		anEvent: 	[(17.0@13.0) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(168362496)
	Arguments and temporary variables: 
		anEvent: 	[(17.0@13.0) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(260190208)
		submorphs: 	an Array(an AlignmentMorph(909179904))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (797450240) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(302349824)'Do it'
		iconMorph: 	an ImageMorph(380562432)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@309) mouseUp 2050729 nil]
		focusHolder: 	a SpToolbarButtonMorph(168362496)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(17.0@13.0) mouseUp 2050729 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(529@309.0) corner: (545@325.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@309.0) corner: (545@325.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(793701888)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@309) mouseUp 2050729 nil]
		targetOffset: 	(17.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(1015088640)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(529@309) mouseUp 2050729 nil]
		focusHolder: 	a SpToolbarButtonMorph(168362496)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(17.0@13.0) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(529@309.0) corner: (545@325.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@309.0) corner: (545@325.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(793701888)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@309) mouseUp 2050729 nil]
		targetOffset: 	(17.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@309) mouseUp 2050729 nil]
		focusHolder: 	a SpToolbarButtonMorph(168362496)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(529@309.0) corner: (545@325.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@309.0) corner: (545@325.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(793701888)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@309) mouseUp 2050729 nil]
		targetOffset: 	(17.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@309) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(529@309.0) corner: (545@325.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@309.0) corner: (545@325.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(793701888)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@309) mouseUp 2050729 nil]
		targetOffset: 	(17.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@309) mouseUp 2050729 nil]
		evt: 	[(529@309) mouseUp 2050729 nil]
	Receiver's instance variables: 
		bounds: 	(529@309.0) corner: (545@325.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@309.0) corner: (545@325.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(793701888)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@309) mouseUp 2050729 nil]
		targetOffset: 	(17.0@8.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(529@309) mouseUp 2050729 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
[:sound | 
		Transcript show: sound .
		result := result , sound .
	] in Raindrops>>convertNumber:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 'PlingPlangPlong' instead of '1'.
31 May 2023 7:06:27.033479 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''PlingPlangPlong'' instead of ''1''.'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		actual: 	'PlingPlangPlong'
		expected: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	'PlingPlangPlong'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:06:26.997491-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:06:26.997491-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 'PlingPlangPlong' instead of '1'.
31 May 2023 7:06:27.172848 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''PlingPlangPlong'' instead of ''1''.'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		actual: 	'PlingPlangPlong'
		expected: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	'PlingPlangPlong'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:06:26.997491-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:06:26.997491-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
Error printing the compiledBlock in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
31 May 2023 7:09:02.204086 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

FullBlockClosure(BlockClosure)>>numArgsError:
	Receiver: [:factor :sound | 
		Transcript show: sound .
		Transcript show: factor .
		result := resu...etc...
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		Transcript show: sound .
		Trans...etc...
		numArgs: 	2
		receiver: 	a Raindrops


FullBlockClosure(BlockClosure)>>value:
	Receiver: [:factor :sound | 
		Transcript show: sound .
		Transcript show: factor .
		result := resu...etc...
	Arguments and temporary variables: 
		firstArg: 	'Pling'
		newContext: 	nil
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		Transcript show: sound .
		Trans...etc...
		numArgs: 	2
		receiver: 	a Raindrops


Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		Transcript show: sound .
		Transcript show: factor...etc...
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		Transcript show: sound .
		Transcript show: factor...etc...
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	1
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:09:02.164161-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:09:02.164161-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))


--- The full stack ---
FullBlockClosure(BlockClosure)>>numArgsError:
FullBlockClosure(BlockClosure)>>value:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
31 May 2023 7:09:02.383813 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

FullBlockClosure(BlockClosure)>>numArgsError:
	Receiver: [:factor :sound | 
		Transcript show: sound .
		Transcript show: factor .
		result := resu...etc...
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		Transcript show: sound .
		Trans...etc...
		numArgs: 	2
		receiver: 	a Raindrops


FullBlockClosure(BlockClosure)>>value:
	Receiver: [:factor :sound | 
		Transcript show: sound .
		Transcript show: factor .
		result := resu...etc...
	Arguments and temporary variables: 
		firstArg: 	'Pling'
		newContext: 	nil
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		Transcript show: sound .
		Trans...etc...
		numArgs: 	2
		receiver: 	a Raindrops


Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		Transcript show: sound .
		Transcript show: factor...etc...
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		Transcript show: sound .
		Transcript show: factor...etc...
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	1
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:09:02.164161-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:09:02.164161-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test01_TheSoundFor1Is1)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))


--- The full stack ---
FullBlockClosure(BlockClosure)>>numArgsError:
FullBlockClosure(BlockClosure)>>value:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Raindrops did not understand #r
31 May 2023 7:09:34.309634 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Raindrops(Object)>>doesNotUnderstand: #r
	Receiver: a Raindrops
	Arguments and temporary variables: 
		aMessage: 	r
		exception: 	Instance of Raindrops did not understand #r
		resumeValue: 	nil
	Receiver's instance variables: 
a Raindrops

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ r := Raindrops new r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ r := Raindrops new r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'r := Raindrops new
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 37) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'r := Raindrops new
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 37) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(577103360))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(577103360)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		event: 	[(21.0@16.0) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		evt: 	[(21.0@16.0) mouseUp 2307240 nil]
		all: 	an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(10583111...etc...
		m: 	a SpToolbarButtonMorph(577103360)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(1058311168) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(1058311168) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		evt: 	[(21.0@16.0) mouseUp 2307240 nil]
		all: 	an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(10583111...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@16.0) mouseUp 2307240 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(21.0@16.0) mouseUp 2307240 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(577103360)
	Receiver's instance variables: 
		timeStamp: 	2307240
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(21.0@16.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@16.0) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@16.0) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(680@336) mouseUp 2307240 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(21.0@16.0) mouseUp 2307240 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(680@336.0) corner: (696@352.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(680@336.0) corner: (696@352.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(680@336) mouseUp 2307240 nil]
		targetOffset: 	(21.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(1015088640)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(680@336) mouseUp 2307240 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(21.0@16.0) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(680@336.0) corner: (696@352.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(680@336.0) corner: (696@352.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(680@336) mouseUp 2307240 nil]
		targetOffset: 	(21.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(680@336) mouseUp 2307240 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(680@336.0) corner: (696@352.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(680@336.0) corner: (696@352.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(680@336) mouseUp 2307240 nil]
		targetOffset: 	(21.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(680@336) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(680@336.0) corner: (696@352.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(680@336.0) corner: (696@352.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(680@336) mouseUp 2307240 nil]
		targetOffset: 	(21.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(680@336) mouseUp 2307240 nil]
		evt: 	[(680@336) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(680@336.0) corner: (696@352.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(680@336.0) corner: (696@352.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(680@336) mouseUp 2307240 nil]
		targetOffset: 	(21.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(680@336) mouseUp 2307240 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2307112
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183969280)))
		lastAlarmTime: 	2307228
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2307112
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183969280)))
		lastAlarmTime: 	2307228
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
Raindrops(Object)>>doesNotUnderstand: #r
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Raindrops did not understand #r
31 May 2023 7:09:34.544336 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Raindrops(Object)>>doesNotUnderstand: #r
	Receiver: a Raindrops
	Arguments and temporary variables: 
		aMessage: 	r
		exception: 	Instance of Raindrops did not understand #r
		resumeValue: 	nil
	Receiver's instance variables: 
a Raindrops

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ r := Raindrops new r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ r := Raindrops new r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'r := Raindrops new
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 37) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'r := Raindrops new
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 37) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(577103360))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(577103360)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		event: 	[(21.0@16.0) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		evt: 	[(21.0@16.0) mouseUp 2307240 nil]
		all: 	an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(10583111...etc...
		m: 	a SpToolbarButtonMorph(577103360)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(1058311168) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(1058311168) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		evt: 	[(21.0@16.0) mouseUp 2307240 nil]
		all: 	an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(10583111...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@16.0) mouseUp 2307240 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(21.0@16.0) mouseUp 2307240 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(577103360)
	Receiver's instance variables: 
		timeStamp: 	2307240
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(21.0@16.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@16.0) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@16.0) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(680@336) mouseUp 2307240 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(21.0@16.0) mouseUp 2307240 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(680@336.0) corner: (696@352.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(680@336.0) corner: (696@352.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(680@336) mouseUp 2307240 nil]
		targetOffset: 	(21.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(1015088640)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(680@336) mouseUp 2307240 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(21.0@16.0) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(680@336.0) corner: (696@352.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(680@336.0) corner: (696@352.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(680@336) mouseUp 2307240 nil]
		targetOffset: 	(21.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(680@336) mouseUp 2307240 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(680@336.0) corner: (696@352.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(680@336.0) corner: (696@352.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(680@336) mouseUp 2307240 nil]
		targetOffset: 	(21.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(680@336) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(680@336.0) corner: (696@352.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(680@336.0) corner: (696@352.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(680@336) mouseUp 2307240 nil]
		targetOffset: 	(21.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(680@336) mouseUp 2307240 nil]
		evt: 	[(680@336) mouseUp 2307240 nil]
	Receiver's instance variables: 
		bounds: 	(680@336.0) corner: (696@352.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(680@336.0) corner: (696@352.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(680@336) mouseUp 2307240 nil]
		targetOffset: 	(21.0@11.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(680@336) mouseUp 2307240 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2307112
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183969280)))
		lastAlarmTime: 	2307228
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2307112
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183969280)))
		lastAlarmTime: 	2307228
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
Raindrops(Object)>>doesNotUnderstand: #r
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Raindrops did not understand #r
31 May 2023 7:09:58.423573 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Raindrops(Object)>>doesNotUnderstand: #r
	Receiver: a Raindrops
	Arguments and temporary variables: 
		aMessage: 	r
		exception: 	Instance of Raindrops did not understand #r
		resumeValue: 	nil
	Receiver's instance variables: 
a Raindrops

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ r := Raindrops new r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ r := Raindrops new r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'r := Raindrops new
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 37) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#r->nil )
		aString: 	'r := Raindrops new
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 37) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(577103360))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(577103360)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		event: 	[(14.0@12.0) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		evt: 	[(14.0@12.0) mouseUp 2331383 nil]
		all: 	an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(10583111...etc...
		m: 	a SpToolbarButtonMorph(577103360)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(1058311168) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(1058311168) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		evt: 	[(14.0@12.0) mouseUp 2331383 nil]
		all: 	an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(10583111...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(14.0@12.0) mouseUp 2331383 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(14.0@12.0) mouseUp 2331383 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(577103360)
	Receiver's instance variables: 
		timeStamp: 	2331383
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(14.0@12.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(14.0@12.0) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(14.0@12.0) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(673@332) mouseUp 2331383 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(14.0@12.0) mouseUp 2331383 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(673@332.0) corner: (689@348.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(673@332.0) corner: (689@348.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(673@332) mouseUp 2331383 nil]
		targetOffset: 	(14.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(1015088640)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a NECMen...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(673@332) mouseUp 2331383 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(14.0@12.0) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(673@332.0) corner: (689@348.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(673@332.0) corner: (689@348.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(673@332) mouseUp 2331383 nil]
		targetOffset: 	(14.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(673@332) mouseUp 2331383 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(673@332.0) corner: (689@348.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(673@332.0) corner: (689@348.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(673@332) mouseUp 2331383 nil]
		targetOffset: 	(14.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(673@332) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(673@332.0) corner: (689@348.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(673@332.0) corner: (689@348.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(673@332) mouseUp 2331383 nil]
		targetOffset: 	(14.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(673@332) mouseUp 2331383 nil]
		evt: 	[(673@332) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(673@332.0) corner: (689@348.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(673@332.0) corner: (689@348.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(673@332) mouseUp 2331383 nil]
		targetOffset: 	(14.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(673@332) mouseUp 2331383 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2307112
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183969280)))
		lastAlarmTime: 	2331361
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a NECMen...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2307112
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183969280)))
		lastAlarmTime: 	2331361
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a NECMen...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a NECMen...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
Raindrops(Object)>>doesNotUnderstand: #r
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Raindrops did not understand #r
31 May 2023 7:09:58.525013 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Raindrops(Object)>>doesNotUnderstand: #r
	Receiver: a Raindrops
	Arguments and temporary variables: 
		aMessage: 	r
		exception: 	Instance of Raindrops did not understand #r
		resumeValue: 	nil
	Receiver's instance variables: 
a Raindrops

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ r := Raindrops new r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ r := Raindrops new r convertNumber: 1
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'r := Raindrops new
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 37) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#r->nil )
		aString: 	'r := Raindrops new
r convertNumber: 1'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 37) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'r := Raindrops new
r convertNumber: 1' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(577103360))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(577103360)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		event: 	[(14.0@12.0) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		evt: 	[(14.0@12.0) mouseUp 2331383 nil]
		all: 	an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(10583111...etc...
		m: 	a SpToolbarButtonMorph(577103360)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(1058311168) a SpToolbarB...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(1058311168) a SpToolbarB...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		evt: 	[(14.0@12.0) mouseUp 2331383 nil]
		all: 	an Array(a SpToolbarButtonMorph(577103360) a SpToolbarButtonMorph(10583111...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(14.0@12.0) mouseUp 2331383 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(14.0@12.0) mouseUp 2331383 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(577103360)
	Receiver's instance variables: 
		timeStamp: 	2331383
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(14.0@12.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(14.0@12.0) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(577103360)
	Arguments and temporary variables: 
		anEvent: 	[(14.0@12.0) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(528876544)
		submorphs: 	an Array(an AlignmentMorph(504099328))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (694426112) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(722468352)'Do it'
		iconMorph: 	an ImageMorph(547076608)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(673@332) mouseUp 2331383 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(14.0@12.0) mouseUp 2331383 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(673@332.0) corner: (689@348.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(673@332.0) corner: (689@348.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(673@332) mouseUp 2331383 nil]
		targetOffset: 	(14.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(1015088640)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a NECMen...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(673@332) mouseUp 2331383 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(14.0@12.0) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(673@332.0) corner: (689@348.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(673@332.0) corner: (689@348.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(673@332) mouseUp 2331383 nil]
		targetOffset: 	(14.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(673@332) mouseUp 2331383 nil]
		focusHolder: 	a SpToolbarButtonMorph(577103360)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(673@332.0) corner: (689@348.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(673@332.0) corner: (689@348.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(673@332) mouseUp 2331383 nil]
		targetOffset: 	(14.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(673@332) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(673@332.0) corner: (689@348.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(673@332.0) corner: (689@348.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(673@332) mouseUp 2331383 nil]
		targetOffset: 	(14.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(673@332) mouseUp 2331383 nil]
		evt: 	[(673@332) mouseUp 2331383 nil]
	Receiver's instance variables: 
		bounds: 	(673@332.0) corner: (689@348.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(673@332.0) corner: (689@348.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(101667840)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(673@332) mouseUp 2331383 nil]
		targetOffset: 	(14.0@7.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(673@332) mouseUp 2331383 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2307112
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183969280)))
		lastAlarmTime: 	2331361
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a NECMen...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	2307112
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(183969280)))
		lastAlarmTime: 	2331361
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a NECMen...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a NECMen...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
Raindrops(Object)>>doesNotUnderstand: #r
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
31 May 2023 7:12:00.317725 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

FullBlockClosure(BlockClosure)>>numArgsError:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: (result := result , sound) .
	]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue...etc...
		numArgs: 	2
		receiver: 	a Raindrops


FullBlockClosure(BlockClosure)>>value:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: (result := result , sound) .
	]
	Arguments and temporary variables: 
		firstArg: 	'Pling'
		newContext: 	nil
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue...etc...
		numArgs: 	2
		receiver: 	a Raindrops


Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: (result := resul...etc...
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: (result := resul...etc...
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	3
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:12:00.289984-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:12:00.289984-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))


--- The full stack ---
FullBlockClosure(BlockClosure)>>numArgsError:
FullBlockClosure(BlockClosure)>>value:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
31 May 2023 7:12:00.457213 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

FullBlockClosure(BlockClosure)>>numArgsError:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: (result := result , sound) .
	]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue...etc...
		numArgs: 	2
		receiver: 	a Raindrops


FullBlockClosure(BlockClosure)>>value:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: (result := result , sound) .
	]
	Arguments and temporary variables: 
		firstArg: 	'Pling'
		newContext: 	nil
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue...etc...
		numArgs: 	2
		receiver: 	a Raindrops


Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: (result := resul...etc...
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: (result := resul...etc...
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	3
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:12:00.289984-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:12:00.289984-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))


--- The full stack ---
FullBlockClosure(BlockClosure)>>numArgsError:
FullBlockClosure(BlockClosure)>>value:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
31 May 2023 7:13:20.151589 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

FullBlockClosure(BlockClosure)>>numArgsError:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue...etc...
		numArgs: 	2
		receiver: 	a Raindrops


FullBlockClosure(BlockClosure)>>value:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		firstArg: 	'Pling'
		newContext: 	nil
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue...etc...
		numArgs: 	2
		receiver: 	a Raindrops


Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: [result := resul...etc...
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: [result := resul...etc...
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	3
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:13:20.108131-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:13:20.108131-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))


--- The full stack ---
FullBlockClosure(BlockClosure)>>numArgsError:
FullBlockClosure(BlockClosure)>>value:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
31 May 2023 7:13:20.246777 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

FullBlockClosure(BlockClosure)>>numArgsError:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue...etc...
		numArgs: 	2
		receiver: 	a Raindrops


FullBlockClosure(BlockClosure)>>value:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		firstArg: 	'Pling'
		newContext: 	nil
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0) ifTrue...etc...
		numArgs: 	2
		receiver: 	a Raindrops


Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: [result := resul...etc...
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0) ifTrue: [result := resul...etc...
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	3
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:13:20.108131-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:13:20.108131-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))


--- The full stack ---
FullBlockClosure(BlockClosure)>>numArgsError:
FullBlockClosure(BlockClosure)>>value:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
31 May 2023 7:14:09.957662 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

FullBlockClosure(BlockClosure)>>numArgsError:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0)
			ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0)
			ifT...etc...
		numArgs: 	2
		receiver: 	a Raindrops


FullBlockClosure(BlockClosure)>>value:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0)
			ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		firstArg: 	'Pling'
		newContext: 	nil
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0)
			ifT...etc...
		numArgs: 	2
		receiver: 	a Raindrops


Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0)
			ifTrue: [result := re...etc...
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0)
			ifTrue: [result := re...etc...
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	3
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:14:09.928886-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:14:09.928886-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))


--- The full stack ---
FullBlockClosure(BlockClosure)>>numArgsError:
FullBlockClosure(BlockClosure)>>value:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
31 May 2023 7:14:10.044758 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

FullBlockClosure(BlockClosure)>>numArgsError:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0)
			ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0)
			ifT...etc...
		numArgs: 	2
		receiver: 	a Raindrops


FullBlockClosure(BlockClosure)>>value:
	Receiver: [:factor :sound | 
		(anInteger \\ factor = 0)
			ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		firstArg: 	'Pling'
		newContext: 	nil
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ factor = 0)
			ifT...etc...
		numArgs: 	2
		receiver: 	a Raindrops


Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0)
			ifTrue: [result := re...etc...
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ factor = 0)
			ifTrue: [result := re...etc...
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	3
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:14:09.928886-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:14:09.928886-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))


--- The full stack ---
FullBlockClosure(BlockClosure)>>numArgsError:
FullBlockClosure(BlockClosure)>>value:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 'PlingPlangPlong' instead of 'Pling'.
31 May 2023 7:15:24.745179 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''PlingPlangPlong'' instead of ''Pling''.'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		actual: 	'PlingPlangPlong'
		expected: 	'Pling'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	'PlingPlangPlong'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:15:24.701142-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:15:24.701142-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 'PlingPlangPlong' instead of 'Pling'.
31 May 2023 7:15:24.925744 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''PlingPlangPlong'' instead of ''Pling''.'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		actual: 	'PlingPlangPlong'
		expected: 	'Pling'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	'PlingPlangPlong'
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:15:24.701142-04:00
		failures: 	a Set(RaindropsTest>>#test02_TheSoundFor3IsPling)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BloTHERE_BE_DRAGONS_HERE
ArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
31 May 2023 7:16:29.510459 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

FullBlockClosure(BlockClosure)>>numArgsError:
	Receiver: [:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: ...etc...
		numArgs: 	2
		receiver: 	a Raindrops


FullBlockClosure(BlockClosure)>>value:
	Receiver: [:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		firstArg: 	'Pling'
		newContext: 	nil
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: ...etc...
		numArgs: 	2
		receiver: 	a Raindrops


Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: [result := result ...etc...
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: [result := result ...etc...
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	3
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:16:29.488897-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:16:29.488897-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))


--- The full stack ---
FullBlockClosure(BlockClosure)>>numArgsError:
FullBlockClosure(BlockClosure)>>value:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ArgumentsCountMismatch: This block accepts 2 arguments, but was called with 1 argument.
31 May 2023 7:16:29.606157 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

FullBlockClosure(BlockClosure)>>numArgsError:
	Receiver: [:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		numArgsForInvocation: 	1
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: ...etc...
		numArgs: 	2
		receiver: 	a Raindrops


FullBlockClosure(BlockClosure)>>value:
	Receiver: [:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: [result := result , sound] .
	]
	Arguments and temporary variables: 
		firstArg: 	'Pling'
		newContext: 	nil
	Receiver's instance variables: 
		outerContext: 	Raindrops>>convertNumber:
		startpc: 	a CompiledBlock: [:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: ...etc...
		numArgs: 	2
		receiver: 	a Raindrops


Dictionary>>valuesDo:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: [result := result ...etc...
		eachIndex: 	1
		eachAssociation: 	3->'Pling'
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Dictionary>>do:
	Receiver: a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Arguments and temporary variables: 
		aBlock: 	[:factor :sound | 
		(anInteger \\ 3 = 0)
			ifTrue: [result := result ...etc...
	Receiver's instance variables: 
		tally: 	3
		array: 	{3->'Pling'. 5->'Plang'. 7->'Plong'. nil. nil}


Raindrops>>convertNumber:
	Receiver: a Raindrops
	Arguments and temporary variables: 
		result: 	''
		anInteger: 	3
		sounds: 	a Dictionary(3->'Pling' 5->'Plang' 7->'Plong' )
	Receiver's instance variables: 
a Raindrops

RaindropsTest>>test02_TheSoundFor3IsPling
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:16:29.488897-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:16:29.488897-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RaindropsTest>>#test02_TheSoundFor3IsPling)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test02_TheSoundFor3IsPling


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test02_TheSoundFor3IsPling
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_TheSoundFor3IsPling
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
		testSelector: 	#test02_TheSoundFor3IsPling
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_TheSoundFor3IsPling)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_TheSoundFor3IsPling))


--- The full stack ---
FullBlockClosure(BlockClosure)>>numArgsError:
FullBlockClosure(BlockClosure)>>value:
Dictionary>>valuesDo:
Dictionary>>do:
Raindrops>>convertNumber:
RaindropsTest>>test02_TheSoundFor3IsPling
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '' instead of '1'.
31 May 2023 7:19:07.04048 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got '''' instead of ''1''.'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		actual: 	''
		expected: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	''
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:19:07.008254-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:19:07.008254-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '' instead of '1'.
31 May 2023 7:19:07.137129 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got '''' instead of ''1''.'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		actual: 	''
		expected: 	'1'
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test01_TheSoundFor1Is1
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	''
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:19:07.008254-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:19:07.008254-04:00
		failures: 	a Set(RaindropsTest>>#test01_TheSoundFor1Is1)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test01_TheSoundFor1Is1


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test01_TheSoundFor1Is1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test03_TheSoundFor5IsPlang #test09_TheSou...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_TheSoundFor1Is1
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
		testSelector: 	#test01_TheSoundFor1Is1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_TheSoundFor1Is1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_TheSoundFor1Is1))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test01_TheSoundFor1Is1
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleBTHERE_BE_DRAGONS_HERE
TestFailure: Got '' instead of '8'.
31 May 2023 7:19:17.237399 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got '''' instead of ''8''.'
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		actual: 	''
		expected: 	'8'
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		result: 	''
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	nil
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:19:17.126335-04:00
		failures: 	a Set(RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:19:17.126335-04:00
		failures: 	a Set(RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBas...etc...
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test17_TheSoundFor105IsPlingPlangPlongAsI...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindrop...etc...
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindropSoundAs3Is...etc...
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindrop...etc...
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindropSoundAs3Is...etc...
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindrop...etc...
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindrop...etc...
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentN...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentN...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindrop...etc...
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARain...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got '' instead of '8'.
31 May 2023 7:19:17.404613 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

RaindropsTest(TestAsserter)>>assert:description:resumable:
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got '''' instead of ''8''.'
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:description:
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestAsserter)>>assert:equals:
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		actual: 	''
		expected: 	'8'
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest>>test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		result: 	''
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest(TestCase)>>performTest
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...


RaindropsTest(TestCase)>>runCase
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


RaindropsTest(TestCase)>>runCaseManaged
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:19:17.126335-04:00
		failures: 	a Set(RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsThe...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:19:17.126335-04:00
		failures: 	a Set(RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RaindropsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...


RaindropsTest(TestCase)>>debug
	Receiver: RaindropsTest>>#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		expectedFails: 	#()
		raindropsCalculator: 	a Raindrops


RaindropsTest class(TestCase class)>>debug:
	Receiver: RaindropsTest
	Arguments and temporary variables: 
		aSymbol: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBas...etc...
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->RaindropsTest>>#setUp #test01_TheSoundFo...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#RaindropsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Raindrops'
		history: 	a Dictionary(#errors->a Set(#test17_TheSoundFor105IsPlingPlangPlongAsI...etc...
		solutionId: 	'f0240e68d0bb43998bc2d745206773c1'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		testClass: 	RaindropsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindrop...etc...
		runTestCases: 	{RaindropsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindropSoundAs3Is...etc...
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
		each: 	RaindropsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindrop...etc...
		runTestCases: 	{RaindropsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(RaindropsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	RaindropsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{RaindropsTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindropSoundAs3Is...etc...
		testSelector: 	#test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotT...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindrop...etc...
		runTestCases: 	{RaindropsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheE...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindrop...etc...
		runTestCases: 	{RaindropsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentN...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentN...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_2ToThePower3DoesNotMakeARaindrop...etc...
		runTestCases: 	{RaindropsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a C<<error during printing>>


--- The full stack ---
RaindropsTest(TestAsserter)>>assert:description:resumable:
RaindropsTest(TestAsserter)>>assert:description:
RaindropsTest(TestAsserter)>>assert:equals:
RaindropsTest>>test06_2ToThePower3DoesNotMakeARaindropSoundAs3IsTheExponentNotTheBase
RaindropsTest(TestCase)>>performTest
[self setUp.
	self performTest] in RaindropsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RaindropsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RaindropsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
RaindropsTest(TestCase)>>debug
RaindropsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#Isogram is missing, and does not understand #new
31 May 2023 7:35:47.878943 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(Isogram)
		aMessage: 	new
		exception: 	#Isogram is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

IsogramTest>>setUp
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	nil
		isogramCalculator: 	nil


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	nil
		isogramCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	nil
		isogramCalculator: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	nil
		isogramCalculator: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	nil


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
IsogramTest>>setUp
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#Isogram is missing, and does not understand #new
31 May 2023 7:35:47.994309 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(Isogram)
		aMessage: 	new
		exception: 	#Isogram is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

IsogramTest>>setUp
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	nil


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	nil


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
IsogramTest>>setUp
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Isogram did not understand #isIsogramPhrase:
31 May 2023 7:35:55.425042 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Isogram(Object)>>doesNotUnderstand: #isIsogramPhrase:
	Receiver: an Isogram
	Arguments and temporary variables: 
		aMessage: 	isIsogramPhrase: ''
		exception: 	Instance of Isogram did not understand #isIsogramPhrase:
		resumeValue: 	nil
	Receiver's instance variables: 
an Isogram

IsogramTest>>test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestCase)>>performTest
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
Isogram(Object)>>doesNotUnderstand: #isIsogramPhrase:
IsogramTest>>test01_CheckIfTheGivenStringIsAnIsogramEmptyString
IsogramTest(TestCase)>>performTest
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Isogram did not understand #isIsogramPhrase:
31 May 2023 7:35:55.525666 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Isogram(Object)>>doesNotUnderstand: #isIsogramPhrase:
	Receiver: an Isogram
	Arguments and temporary variables: 
		aMessage: 	isIsogramPhrase: ''
		exception: 	Instance of Isogram did not understand #isIsogramPhrase:
		resumeValue: 	nil
	Receiver's instance variables: 
an Isogram

IsogramTest>>test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestCase)>>performTest
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
Isogram(Object)>>doesNotUnderstand: #isIsogramPhrase:
IsogramTest>>test01_CheckIfTheGivenStringIsAnIsogramEmptyString
IsogramTest(TestCase)>>performTest
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got True instead of true.
31 May 2023 7:36:25.345935 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

IsogramTest(TestAsserter)>>assert:description:resumable:
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got True instead of true.'
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:description:
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:equals:
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		actual: 	True
		expected: 	true
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest>>test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	True
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestCase)>>performTest
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
IsogramTest(TestAsserter)>>assert:description:resumable:
IsogramTest(TestAsserter)>>assert:description:
IsogramTest(TestAsserter)>>assert:equals:
IsogramTest>>test01_CheckIfTheGivenStringIsAnIsogramEmptyString
IsogramTest(TestCase)>>performTest
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got True instead of true.
31 May 2023 7:36:25.440375 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

IsogramTest(TestAsserter)>>assert:description:resumable:
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got True instead of true.'
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:description:
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:equals:
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		actual: 	True
		expected: 	true
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest>>test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	True
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestCase)>>performTest
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:35:47.786662-04:00
		failures: 	a Set(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		errors: 	an OrderedCollection(IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsog...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Arguments and temporary variables: 
		result: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyStrin...etc...
		testSelector: 	#test01_CheckIfTheGivenStringIsAnIsogramEmptyString
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogramEmptyString))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
IsogramTest(TestAsserter)>>assert:description:resumable:
IsogramTest(TestAsserter)>>assert:description:
IsogramTest(TestAsserter)>>assert:equals:
IsogramTest>>test01_CheckIfTheGivenStringIsAnIsogramEmptyString
IsogramTest(TestCase)>>performTest
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got true instead of false.
31 May 2023 7:45:36.8308 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

IsogramTest(TestAsserter)>>assert:description:resumable:
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got true instead of false.'
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:description:
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:equals:
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		actual: 	true
		expected: 	false
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest>>test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCase
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	true
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest(TestCase)>>performTest
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:45:36.793617-04:00
		failures: 	a Set(IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:45:36.793617-04:00
		failures: 	a Set(IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInM...etc...
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#test07_CheckIfTheGiven...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplic...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedChar...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedChar...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
IsogramTest(TestAsserter)>>assert:description:resumable:
IsogramTest(TestAsserter)>>assert:description:
IsogramTest(TestAsserter)>>assert:equals:
IsogramTest>>test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCase
IsogramTest(TestCase)>>performTest
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got true instead of false.
31 May 2023 7:45:36.914896 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

IsogramTest(TestAsserter)>>assert:description:resumable:
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got true instead of false.'
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:description:
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:equals:
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		actual: 	true
		expected: 	false
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest>>test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCase
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	true
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestCase)>>performTest
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:45:36.793617-04:00
		failures: 	a Set(IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:45:36.793617-04:00
		failures: 	a Set(IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInM...etc...
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#test07_CheckIfTheGiven...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		testSelector: 	#test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplic...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedChar...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedChar...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test06_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
IsogramTest(TestAsserter)>>assert:description:resumable:
IsogramTest(TestAsserter)>>assert:description:
IsogramTest(TestAsserter)>>assert:equals:
IsogramTest>>test06_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCase
IsogramTest(TestCase)>>performTest
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got false instead of true.
31 May 2023 7:45:51.419889 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

IsogramTest(TestAsserter)>>assert:description:resumable:
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got false instead of true.'
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:description:
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:equals:
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		actual: 	false
		expected: 	true
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest>>test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		result: 	false
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest(TestCase)>>performTest
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:45:51.396017-04:00
		failures: 	a Set(IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupName...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:45:51.396017-04:00
		failures: 	a Set(IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupName...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#test06_CheckIfTheGiven...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogramMadeupName...etc...
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogramMadeupName...etc...
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThat...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsog...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsog...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
IsogramTest(TestAsserter)>>assert:description:resumable:
IsogramTest(TestAsserter)>>assert:description:
IsogramTest(TestAsserter)>>assert:equals:
IsogramTest>>test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
IsogramTest(TestCase)>>performTest
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got false instead of true.
31 May 2023 7:45:51.479069 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

IsogramTest(TestAsserter)>>assert:description:resumable:
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got false instead of true.'
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:description:
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:equals:
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		actual: 	false
		expected: 	true
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest>>test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		result: 	false
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestCase)>>performTest
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:45:51.396017-04:00
		failures: 	a Set(IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupName...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatI...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:45:51.396017-04:00
		failures: 	a Set(IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupName...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIs...etc...


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#test06_CheckIfTheGiven...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogramMadeupName...etc...
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogramMadeupName...etc...
		testSelector: 	#test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThat...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsog...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsog...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test11_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
IsogramTest(TestAsserter)>>assert:description:resumable:
IsogramTest(TestAsserter)>>assert:description:
IsogramTest(TestAsserter)>>assert:equals:
IsogramTest>>test11_CheckIfTheGivenStringIsAnIsogramMadeupNameThatIsAnIsogram
IsogramTest(TestCase)>>performTest
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got true instead of false.
31 May 2023 7:49:10.860246 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

IsogramTest(TestAsserter)>>assert:description:resumable:
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got true instead of false.'
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:description:
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:equals:
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		actual: 	true
		expected: 	false
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest>>test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCaseLowercaseFirst
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	true
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


IsogramTest(TestCase)>>performTest
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	nil
		isogramCalculator: 	an Isogram


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:49:10.823419-04:00
		failures: 	a Set(IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:49:10.823419-04:00
		failures: 	a Set(IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInM...etc...
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#test07_CheckIfTheGiven...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplic...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedChar...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedChar...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
IsogramTest(TestAsserter)>>assert:description:resumable:
IsogramTest(TestAsserter)>>assert:description:
IsogramTest(TestAsserter)>>assert:equals:
IsogramTest>>test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCaseLowercaseFirst
IsogramTest(TestCase)>>performTest
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got true instead of false.
31 May 2023 7:49:10.931043 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

IsogramTest(TestAsserter)>>assert:description:resumable:
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got true instead of false.'
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:description:
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestAsserter)>>assert:equals:
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		actual: 	true
		expected: 	false
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest>>test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCaseLowercaseFirst
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	true
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest(TestCase)>>performTest
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...


IsogramTest(TestCase)>>runCase
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


IsogramTest(TestCase)>>runCaseManaged
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:49:10.823419-04:00
		failures: 	a Set(IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplica...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:49:10.823419-04:00
		failures: 	a Set(IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	IsogramTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicat...etc...


IsogramTest(TestCase)>>debug
	Receiver: IsogramTest>>#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCas...etc...
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		expectedFails: 	#()
		isogramCalculator: 	an Isogram


IsogramTest class(TestCase class)>>debug:
	Receiver: IsogramTest
	Arguments and temporary variables: 
		aSymbol: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInM...etc...
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->IsogramTest>>#setUp #test01_CheckIfTheGi...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IsogramTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Isogram'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#test07_CheckIfTheGiven...etc...
		solutionId: 	'0d85101a5d684988ba8e254ae1c18dbb'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		testClass: 	IsogramTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
		each: 	IsogramTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(IsogramTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	2
		each: 	IsogramTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. IsogramTest. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogramWordWithDu...etc...
		testSelector: 	#test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharact...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplic...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedChar...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedChar...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIsogram...etc...
		runTestCases: 	{IsogramTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test07_CheckIfTheGivenStringIsAnIso...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
IsogramTest(TestAsserter)>>assert:description:resumable:
IsogramTest(TestAsserter)>>assert:description:
IsogramTest(TestAsserter)>>assert:equals:
IsogramTest>>test07_CheckIfTheGivenStringIsAnIsogramWordWithDuplicatedCharacterInMixedCaseLowercaseFirst
IsogramTest(TestCase)>>performTest
[self setUp.
	self performTest] in IsogramTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
IsogramTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in IsogramTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
IsogramTest(TestCase)>>debug
IsogramTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#Leap is missing, and does not understand #new
31 May 2023 7:52:54.953819 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(Leap)
		aMessage: 	new
		exception: 	#Leap is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

LeapTest>>setUp
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	nil
		leapCalculator: 	nil


[self setUp.
	self performTest] in LeapTest(TestCase)>>runCase
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	nil
		leapCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	LeapTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear


LeapTest(TestCase)>>runCase
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	nil
		leapCalculator: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


LeapTest(TestCase)>>runCaseManaged
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	nil
		leapCalculator: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:52:54.930905-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(LeapTest>>#test01_YearNotDivisibleBy4CommonYear)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:52:54.930905-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(LeapTest>>#test01_YearNotDivisibleBy4CommonYear)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in LeapTest(TestCase)>>debug
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	LeapTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear


LeapTest(TestCase)>>debug
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	nil


LeapTest class(TestCase class)>>debug:
	Receiver: LeapTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->LeapTest>>#setUp #test01_YearNotDivisibl...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LeapTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Leap'
		history: 	a Dictionary(#errors->a Set(#test05_YearDivisibleBy400LeapYear #test06...etc...
		solutionId: 	'0e9a893d261841b2892d98d5e4585b9a'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		testClass: 	LeapTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		each: 	LeapTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(LeapTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	LeapTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{LeapTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYea...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
LeapTest>>setUp
[self setUp.
	self performTest] in LeapTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
LeapTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
LeapTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in LeapTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
LeapTest(TestCase)>>debug
LeapTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#Leap is missing, and does not understand #new
31 May 2023 7:52:55.020964 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(Leap)
		aMessage: 	new
		exception: 	#Leap is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

LeapTest>>setUp
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	nil


[self setUp.
	self performTest] in LeapTest(TestCase)>>runCase
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	LeapTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear


LeapTest(TestCase)>>runCase
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


LeapTest(TestCase)>>runCaseManaged
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:52:54.930905-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(LeapTest>>#test01_YearNotDivisibleBy4CommonYear)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:52:54.930905-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(LeapTest>>#test01_YearNotDivisibleBy4CommonYear)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in LeapTest(TestCase)>>debug
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	LeapTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear


LeapTest(TestCase)>>debug
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	nil


LeapTest class(TestCase class)>>debug:
	Receiver: LeapTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->LeapTest>>#setUp #test01_YearNotDivisibl...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LeapTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Leap'
		history: 	a Dictionary(#errors->a Set(#test05_YearDivisibleBy400LeapYear #test06...etc...
		solutionId: 	'0e9a893d261841b2892d98d5e4585b9a'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		testClass: 	LeapTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		each: 	LeapTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(LeapTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	LeapTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{LeapTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYea...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
LeapTest>>setUp
[self setUp.
	self performTest] in LeapTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
LeapTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
LeapTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in LeapTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
LeapTest(TestCase)>>debug
LeapTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Leap did not understand #leapYear:
31 May 2023 7:53:02.220122 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Leap(Object)>>doesNotUnderstand: #leapYear:
	Receiver: a Leap
	Arguments and temporary variables: 
		aMessage: 	leapYear: 2015
		exception: 	Instance of Leap did not understand #leapYear:
		resumeValue: 	nil
	Receiver's instance variables: 
a Leap

LeapTest>>test01_YearNotDivisibleBy4CommonYear
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


LeapTest(TestCase)>>performTest
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


[self setUp.
	self performTest] in LeapTest(TestCase)>>runCase
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	LeapTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear


LeapTest(TestCase)>>runCase
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


LeapTest(TestCase)>>runCaseManaged
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:52:54.930905-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(LeapTest>>#test01_YearNotDivisibleBy4CommonYear Le...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:52:54.930905-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(LeapTest>>#test01_YearNotDivisibleBy4CommonYear Le...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in LeapTest(TestCase)>>debug
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	LeapTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear


LeapTest(TestCase)>>debug
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


LeapTest class(TestCase class)>>debug:
	Receiver: LeapTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->LeapTest>>#setUp #test01_YearNotDivisibl...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LeapTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Leap'
		history: 	a Dictionary(#errors->a Set(#test05_YearDivisibleBy400LeapYear #test06...etc...
		solutionId: 	'0e9a893d261841b2892d98d5e4585b9a'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		testClass: 	LeapTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		each: 	LeapTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(LeapTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	LeapTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{LeapTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYea...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
Leap(Object)>>doesNotUnderstand: #leapYear:
LeapTest>>test01_YearNotDivisibleBy4CommonYear
LeapTest(TestCase)>>performTest
[self setUp.
	self performTest] in LeapTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
LeapTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
LeapTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in LeapTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
LeapTest(TestCase)>>debug
LeapTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Leap did not understand #leapYear:
31 May 2023 7:53:02.274622 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Leap(Object)>>doesNotUnderstand: #leapYear:
	Receiver: a Leap
	Arguments and temporary variables: 
		aMessage: 	leapYear: 2015
		exception: 	Instance of Leap did not understand #leapYear:
		resumeValue: 	nil
	Receiver's instance variables: 
a Leap

LeapTest>>test01_YearNotDivisibleBy4CommonYear
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


LeapTest(TestCase)>>performTest
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


[self setUp.
	self performTest] in LeapTest(TestCase)>>runCase
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	LeapTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear


LeapTest(TestCase)>>runCase
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


LeapTest(TestCase)>>runCaseManaged
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:52:54.930905-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(LeapTest>>#test01_YearNotDivisibleBy4CommonYear Le...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:52:54.930905-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(LeapTest>>#test01_YearNotDivisibleBy4CommonYear Le...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in LeapTest(TestCase)>>debug
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	LeapTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	LeapTest>>#test01_YearNotDivisibleBy4CommonYear


LeapTest(TestCase)>>debug
	Receiver: LeapTest>>#test01_YearNotDivisibleBy4CommonYear
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		expectedFails: 	#()
		leapCalculator: 	a Leap


LeapTest class(TestCase class)>>debug:
	Receiver: LeapTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->LeapTest>>#setUp #test01_YearNotDivisibl...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LeapTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Leap'
		history: 	a Dictionary(#errors->a Set(#test05_YearDivisibleBy400LeapYear #test06...etc...
		solutionId: 	'0e9a893d261841b2892d98d5e4585b9a'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		testClass: 	LeapTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
		each: 	LeapTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(LeapTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	1
		each: 	LeapTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{LeapTest. nil. nil. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
		testSelector: 	#test01_YearNotDivisibleBy4CommonYear
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYear))
		runTestCases: 	{LeapTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_YearNotDivisibleBy4CommonYea...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
Leap(Object)>>doesNotUnderstand: #leapYear:
LeapTest>>test01_YearNotDivisibleBy4CommonYear
LeapTest(TestCase)>>performTest
[self setUp.
	self performTest] in LeapTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
LeapTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
LeapTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in LeapTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
LeapTest(TestCase)>>debug
LeapTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#TwelveDays is missing, and does not understand #new
31 May 2023 7:59:42.451944 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(TwelveDays)
		aMessage: 	new
		exception: 	#TwelveDays is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

TwelveDaysTest>>setUp
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	nil


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:59:42.39863-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:59:42.39863-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	nil


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
TwelveDaysTest>>setUp
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#TwelveDays is missing, and does not understand #new
31 May 2023 7:59:42.571243 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(TwelveDays)
		aMessage: 	new
		exception: 	#TwelveDays is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

TwelveDaysTest>>setUp
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	nil


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:59:42.39863-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:59:42.39863-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	nil


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
TwelveDaysTest>>setUp
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of TwelveDays did not understand #reciteStartVerse:endVerse:
31 May 2023 7:59:52.270201 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDays(Object)>>doesNotUnderstand: #reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		aMessage: 	reciteStartVerse: 1 endVerse: 1
		exception: 	Instance of TwelveDays did not understand #reciteStartVerse:endVerse...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:59:42.39863-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:59:42.39863-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
TwelveDays(Object)>>doesNotUnderstand: #reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of TwelveDays did not understand #reciteStartVerse:endVerse:
31 May 2023 7:59:52.351615 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDays(Object)>>doesNotUnderstand: #reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		aMessage: 	reciteStartVerse: 1 endVerse: 1
		exception: 	Instance of TwelveDays did not understand #reciteStartVerse:endVerse...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:59:42.39863-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T19:59:42.39863-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
TwelveDays(Object)>>doesNotUnderstand: #reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldBeImplemented: #reciteStartVerse:endVerse: should have been implemented in TwelveDays
31 May 2023 8:00:34.375059 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDays(Object)>>shouldBeImplemented
	Receiver: a TwelveDays
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a TwelveDays

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		anInteger: 	1
		anInteger2: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:00:34.337539-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:00:34.337539-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test01_VerseFirstDayAPartridgeInAPearTree...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
TwelveDays(Object)>>shouldBeImplemented
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldBeImplemented: #reciteStartVerse:endVerse: should have been implemented in TwelveDays
31 May 2023 8:00:34.517761 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDays(Object)>>shouldBeImplemented
	Receiver: a TwelveDays
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a TwelveDays

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		anInteger: 	1
		anInteger2: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironTHERE_BE_DRAGONS_HERE
ShouldBeImplemented: #reciteStartVerse:endVerse: should have been implemented in TwelveDays
31 May 2023 8:00:44.295625 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDays(Object)>>shouldBeImplemented
	Receiver: a TwelveDays
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a TwelveDays

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		anInteger: 	1
		anInteger2: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:00:44.252796-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:00:44.252796-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test01_VerseFirstDayAPartridgeInAPearTree...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
TwelveDays(Object)>>shouldBeImplemented
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldBeImplemented: #reciteStartVerse:endVerse: should have been implemented in TwelveDays
31 May 2023 8:00:44.36847 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDays(Object)>>shouldBeImplemented
	Receiver: a TwelveDays
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a TwelveDays

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		anInteger: 	1
		anInteger2: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:00:44.252796-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:00:44.252796-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test01_VerseFirstDayAPartridgeInAPearTree...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
TwelveDays(Object)>>shouldBeImplemented
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 'nothing' instead of #('On the first day of Christmas my true love gave to me: a Partridge in a Pear Tree.').
31 May 2023 8:00:59.553017 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDaysTest(TestAsserter)>>assert:description:resumable:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''nothing'' instead of #(''On the first day of Christmas my true ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:description:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:equals:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		actual: 	'nothing'
		expected: 	#('On the first day of Christmas my true love gave to me: a Partridge...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	'nothing'
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:00:44.252796-04:00
		failures: 	a Set(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree)
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 1 error, ...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:00:44.252796-04:00
		failures: 	a Set(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree)
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 1 error, 0 ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 1 error, 0 ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test01_VerseFirstDayAPartridgeInAPearTree...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
TwelveDaysTest(TestAsserter)>>assert:description:resumable:
TwelveDaysTest(TestAsserter)>>assert:description:
TwelveDaysTest(TestAsserter)>>assert:equals:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 'nothing' instead of #('On the first day of Christmas my true love gave to me: a Partridge in a Pear Tree.').
31 May 2023 8:00:59.633437 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDaysTest(TestAsserter)>>assert:description:resumable:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''nothing'' instead of #(''On the first day of Christmas my true ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:description:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:equals:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		actual: 	'nothing'
		expected: 	#('On the first day of Christmas my true love gave to me: a Partridge...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	'nothing'
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:00:44.252796-04:00
		failures: 	a Set(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree)
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 1 error, ...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:00:44.252796-04:00
		failures: 	a Set(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree)
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 1 error, 0 ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 1 error, 0 ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test01_VerseFirstDayAPartridgeInAPearTree...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
TwelveDaysTest(TestAsserter)>>assert:description:resumable:
TwelveDaysTest(TestAsserter)>>assert:description:
TwelveDaysTest(TestAsserter)>>assert:equals:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 'nothing' instead of #('On the first day of Christmas my true love gave to me: a Partridge in a Pear Tree.' 'On the second day of Christmas my true love gave to me: two Turtle Doves, and a Partridge in a Pear Tree.' 'On the third day of Christmas my true love gave to me: three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the fourth day of Christmas my true love gave to me: four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the fifth day of Christmas my true love gave to me: five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the sixth day of Christmas my true love gave to me: six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the seventh day of Christmas my true love gave to me: seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the eighth day of Christmas my true love gave to me: eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the ninth day of Christmas my true love gave to me: nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the tenth day of Christmas my true love gave to me: ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the eleventh day of Christmas my true love gave to me: eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the twelfth day of Christmas my true love gave to me: twelve Drummers Drumming, eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.').
31 May 2023 8:01:17.46918 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDaysTest(TestAsserter)>>assert:description:resumable:
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''nothing'' instead of #(''On the first day of Christmas my true ...etc...
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:description:
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:equals:
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		actual: 	'nothing'
		expected: 	#('On the first day of Christmas my true love gave to me: a Partridge...etc...
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest>>test15_LyricsRecitesTheWholeSong
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		result: 	'nothing'
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:01:17.426259-04:00
		failures: 	a Set(TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:01:17.426259-04:00
		failures: 	a Set(TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test01_VerseFirstDayAPartridgeInAPearTree...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong)
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong)
		testSelector: 	#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
TwelveDaysTest(TestAsserter)>>assert:description:resumable:
TwelveDaysTest(TestAsserter)>>assert:description:
TwelveDaysTest(TestAsserter)>>assert:equals:
TwelveDaysTest>>test15_LyricsRecitesTheWholeSong
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 'nothing' instead of #('On the first day of Christmas my true love gave to me: a Partridge in a Pear Tree.' 'On the second day of Christmas my true love gave to me: two Turtle Doves, and a Partridge in a Pear Tree.' 'On the third day of Christmas my true love gave to me: three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the fourth day of Christmas my true love gave to me: four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the fifth day of Christmas my true love gave to me: five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the sixth day of Christmas my true love gave to me: six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the seventh day of Christmas my true love gave to me: seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the eighth day of Christmas my true love gave to me: eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the ninth day of Christmas my true love gave to me: nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the tenth day of Christmas my true love gave to me: ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the eleventh day of Christmas my true love gave to me: eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.' 'On the twelfth day of Christmas my true love gave to me: twelve Drummers Drumming, eleven Pipers Piping, ten Lords-a-Leaping, nine Ladies Dancing, eight Maids-a-Milking, seven Swans-a-Swimming, six Geese-a-Laying, five Gold Rings, four Calling Birds, three French Hens, two Turtle Doves, and a Partridge in a Pear Tree.').
31 May 2023 8:01:17.556414 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDaysTest(TestAsserter)>>assert:description:resumable:
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got ''nothing'' instead of #(''On the first day of Christmas my true ...etc...
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:description:
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:equals:
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		actual: 	'nothing'
		expected: 	#('On the first day of Christmas my true love gave to me: a Partridge...etc...
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest>>test15_LyricsRecitesTheWholeSong
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		result: 	'nothing'
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:01:17.426259-04:00
		failures: 	a Set(TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:01:17.426259-04:00
		failures: 	a Set(TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test15_LyricsRecitesTheWholeSong
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test01_VerseFirstDayAPartridgeInAPearTree...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong)
		testSelector: 	#test15_LyricsRecitesTheWholeSong
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong)
		testSelector: 	#test15_LyricsRecitesTheWholeSong
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test15_LyricsRecitesTheWholeSong))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
TwelveDaysTest(TestAsserter)>>assert:description:resumable:
TwelveDaysTest(TestAsserter)>>assert:description:
TwelveDaysTest(TestAsserter)>>assert:equals:
TwelveDaysTest>>test15_LyricsRecitesTheWholeSong
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Array did not understand #put:
31 May 2023 8:10:56.367887 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>doesNotUnderstand: #put:
	Receiver: #()
	Arguments and temporary variables: 
		aMessage: 	put: 'On the first day of Christmas my true love gave to me: a Partri...etc...
		exception: 	Instance of Array did not understand #put:
		resumeValue: 	nil
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:10:56.340131-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:10:56.340131-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
Array(Object)>>doesNotUnderstand: #put:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Array did not understand #put:
31 May 2023 8:10:56.471664 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>doesNotUnderstand: #put:
	Receiver: #()
	Arguments and temporary variables: 
		aMessage: 	put: 'On the first day of Christmas my true love gave to me: a Partri...etc...
		exception: 	Instance of Array did not understand #put:
		resumeValue: 	nil
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:10:56.340131-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:10:56.340131-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
Array(Object)>>doesNotUnderstand: #put:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
31 May 2023 8:11:24.21953 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	'On the first day of Christmas my true love gave to me: a Partridge ...etc...
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:11:24.192602-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:11:24.192602-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
31 May 2023 8:11:24.301123 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	'On the first day of Christmas my true love gave to me: a Partridge ...etc...
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:11:24.192602-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:11:24.192602-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Array did not understand #start
31 May 2023 8:12:38.258448 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>doesNotUnderstand: #start
	Receiver: #()
	Arguments and temporary variables: 
		aMessage: 	start
		exception: 	Instance of Array did not understand #start
		resumeValue: 	nil
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	nil
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:12:38.231967-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:12:38.231967-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
Array(Object)>>doesNotUnderstand: #start
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Array did not understand #start
31 May 2023 8:12:38.327813 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>doesNotUnderstand: #start
	Receiver: #()
	Arguments and temporary variables: 
		aMessage: 	start
		exception: 	Instance of Array did not understand #start
		resumeValue: 	nil
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	nil
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:12:38.231967-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:12:38.231967-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
Array(Object)>>doesNotUnderstand: #start
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
31 May 2023 8:13:04.032492 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	'On the first day of Christmas my true love gave to me: a Partridge ...etc...
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:13:03.992071-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:13:03.992071-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
31 May 2023 8:13:04.106607 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	'On the first day of Christmas my true love gave to me: a Partridge ...etc...
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:13:03.992071-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:13:03.992071-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
31 May 2023 8:14:55.928581 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	'On the first day of Christmas my true love gave to me: a Partridge ...etc...
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:14:55.902156-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:14:55.902156-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
31 May 2023 8:14:55.991375 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	'On the first day of Christmas my true love gave to me: a Partridge ...etc...
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:14:55.902156-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:14:55.902156-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
31 May 2023 8:16:06.934432 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #(nil)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
#(nil)

Array(ArrayedCollection)>>add:
	Receiver: #(nil)
	Arguments and temporary variables: 
		newObject: 	'On the first day of Christmas my true love gave to me: a Partridge ...etc...
	Receiver's instance variables: 
#(nil)

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#(nil)
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:16:06.907114-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:16:06.907114-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
31 May 2023 8:16:07.024161 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #(nil)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
#(nil)

Array(ArrayedCollection)>>add:
	Receiver: #(nil)
	Arguments and temporary variables: 
		newObject: 	'On the first day of Christmas my true love gave to me: a Partridge ...etc...
	Receiver's instance variables: 
#(nil)

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#(nil)
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:16:06.907114-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:16:06.907114-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
31 May 2023 8:18:02.234033 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	'On the first day of Christmas my true love gave to me: a Partridge ...etc...
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:18:02.185613-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:18:02.185613-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
ShouldNotImplement: #add: should not have been implemented in Array
31 May 2023 8:18:02.324927 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>shouldNotImplement
	Receiver: #()
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
#()

Array(ArrayedCollection)>>add:
	Receiver: #()
	Arguments and temporary variables: 
		newObject: 	'On the first day of Christmas my true love gave to me: a Partridge ...etc...
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:18:02.185613-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:18:02.185613-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>shouldNotImplement
Array(ArrayedCollection)>>add:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Array did not understand #put:
31 May 2023 8:20:12.406607 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>doesNotUnderstand: #put:
	Receiver: #()
	Arguments and temporary variables: 
		aMessage: 	put: 'On the first day of Christmas my true love gave to me: a Partri...etc...
		exception: 	Instance of Array did not understand #put:
		resumeValue: 	nil
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:20:12.382995-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:20:12.382995-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
Array(Object)>>doesNotUnderstand: #put:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Array did not understand #put:
31 May 2023 8:20:12.48764 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>doesNotUnderstand: #put:
	Receiver: #()
	Arguments and temporary variables: 
		aMessage: 	put: 'On the first day of Christmas my true love gave to me: a Partri...etc...
		exception: 	Instance of Array did not understand #put:
		resumeValue: 	nil
	Receiver's instance variables: 
#()

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#()
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:20:12.382995-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:20:12.382995-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
Array(Object)>>doesNotUnderstand: #put:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
31 May 2023 8:21:19.935862 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(nil)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#(nil)

Array(Object)>>at:put:
	Receiver: #(nil)
	Arguments and temporary variables: 
		index: 	0
		value: 	'On the first day of Christmas my true love gave to me: a Partridge in a...etc...
	Receiver's instance variables: 
#(nil)

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#(nil)
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:21:19.906256-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:21:19.906256-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 0
31 May 2023 8:21:20.031185 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Array(Object)>>errorSubscriptBounds:
	Receiver: #(nil)
	Arguments and temporary variables: 
		index: 	0
	Receiver's instance variables: 
#(nil)

Array(Object)>>at:put:
	Receiver: #(nil)
	Arguments and temporary variables: 
		index: 	0
		value: 	'On the first day of Christmas my true love gave to me: a Partridge in a...etc...
	Receiver's instance variables: 
#(nil)

TwelveDays>>reciteStartVerse:endVerse:
	Receiver: a TwelveDays
	Arguments and temporary variables: 
		start: 	1
		end: 	1
		verses: 	#('a Partridge in a Pear Tree' 'two Turtle Doves' 'three French Hens' '...etc...
		cardinal: 	#('first' 'second' 'third' 'fourth' 'fifth' 'sixth' 'seventh' 'eigth'...etc...
		song: 	#(nil)
		verse: 	1
	Receiver's instance variables: 
a TwelveDays

TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:21:19.906256-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:21:19.906256-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInA...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
Array(Object)>>errorSubscriptBounds:
Array(Object)>>at:put:
TwelveDays>>reciteStartVerse:endVerse:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got #('On the first day of Christmas my true love gave to me: a Partridge in a Pear Tree') instead of #('On the first day of Christmas my true love gave to me: a Partridge in a Pear Tree.').
31 May 2023 8:21:52.064473 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDaysTest(TestAsserter)>>assert:description:resumable:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got #(''On the first day of Christmas my true love gave to me: a Part...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:description:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:equals:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		actual: 	#('On the first day of Christmas my true love gave to me: a Partridge i...etc...
		expected: 	#('On the first day of Christmas my true love gave to me: a Partridge...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	#('On the first day of Christmas my true love gave to me: a Partridge i...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:21:52.027001-04:00
		failures: 	a Set(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:21:52.027001-04:00
		failures: 	a Set(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
TwelveDaysTest(TestAsserter)>>assert:description:resumable:
TwelveDaysTest(TestAsserter)>>assert:description:
TwelveDaysTest(TestAsserter)>>assert:equals:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got #('On the first day of Christmas my true love gave to me: a Partridge in a Pear Tree') instead of #('On the first day of Christmas my true love gave to me: a Partridge in a Pear Tree.').
31 May 2023 8:21:52.132644 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDaysTest(TestAsserter)>>assert:description:resumable:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got #(''On the first day of Christmas my true love gave to me: a Part...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:description:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:equals:
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		actual: 	#('On the first day of Christmas my true love gave to me: a Partridge i...etc...
		expected: 	#('On the first day of Christmas my true love gave to me: a Partridge...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	#('On the first day of Christmas my true love gave to me: a Partridge i...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:21:52.027001-04:00
		failures: 	a Set(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:21:52.027001-04:00
		failures: 	a Set(TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test01_VerseFirstDayAPartridgeInAPearTree
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test11_VerseEleventhDayElevenPipersPiping...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
		testSelector: 	#test01_VerseFirstDayAPartridgeInAPearTree
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTree))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPearTr...etc...
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_VerseFirstDayAPartridgeInAPe...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
TwelveDaysTest(TestAsserter)>>assert:description:resumable:
TwelveDaysTest(TestAsserter)>>assert:description:
TwelveDaysTest(TestAsserter)>>assert:equals:
TwelveDaysTest>>test01_VerseFirstDayAPartridgeInAPearTree
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got #('On the second day of Christmas my true love gave to me: two Turtle Doves.') instead of #('On the second day of Christmas my true love gave to me: two Turtle Doves, and a Partridge in a Pear Tree.').
31 May 2023 8:22:52.497211 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDaysTest(TestAsserter)>>assert:description:resumable:
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got #(''On the second day of Christmas my true love gave to me: two T...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:description:
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:equals:
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		actual: 	#('On the second day of Christmas my true love gave to me: two Turtle D...etc...
		expected: 	#('On the second day of Christmas my true love gave to me: two Turtle...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest>>test02_VerseSecondDayTwoTurtleDoves
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		result: 	#('On the second day of Christmas my true love gave to me: two Turtle D...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	nil
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:22:52.44193-04:00
		failures: 	a Set(TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:22:52.44193-04:00
		failures: 	a Set(TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test13_LyricsRecitesFirstThreeVersesOfThe...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves)
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves)
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
TwelveDaysTest(TestAsserter)>>assert:description:resumable:
TwelveDaysTest(TestAsserter)>>assert:description:
TwelveDaysTest(TestAsserter)>>assert:equals:
TwelveDaysTest>>test02_VerseSecondDayTwoTurtleDoves
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got #('On the second day of Christmas my true love gave to me: two Turtle Doves.') instead of #('On the second day of Christmas my true love gave to me: two Turtle Doves, and a Partridge in a Pear Tree.').
31 May 2023 8:22:52.583512 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

TwelveDaysTest(TestAsserter)>>assert:description:resumable:
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got #(''On the second day of Christmas my true love gave to me: two T...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:description:
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestAsserter)>>assert:equals:
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		actual: 	#('On the second day of Christmas my true love gave to me: two Turtle D...etc...
		expected: 	#('On the second day of Christmas my true love gave to me: two Turtle...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest>>test02_VerseSecondDayTwoTurtleDoves
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		result: 	#('On the second day of Christmas my true love gave to me: two Turtle D...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest(TestCase)>>performTest
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves


TwelveDaysTest(TestCase)>>runCase
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TwelveDaysTest(TestCase)>>runCaseManaged
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:22:52.44193-04:00
		failures: 	a Set(TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:22:52.44193-04:00
		failures: 	a Set(TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TwelveDaysTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves


TwelveDaysTest(TestCase)>>debug
	Receiver: TwelveDaysTest>>#test02_VerseSecondDayTwoTurtleDoves
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		expectedFails: 	#()
		twelveDaysCalculator: 	a TwelveDays


TwelveDaysTest class(TestCase class)>>debug:
	Receiver: TwelveDaysTest
	Arguments and temporary variables: 
		aSymbol: 	#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->TwelveDaysTest>>#setUp #test01_VerseFirs...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#TwelveDaysTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@TwelveDays'
		history: 	a Dictionary(#errors->a Set(#test13_LyricsRecitesFirstThreeVersesOfThe...etc...
		solutionId: 	'a1458829038440a98308da9f6c865a40'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		testClass: 	TwelveDaysTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
		runTestCases: 	{TwelveDaysTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves)
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
		runTestCases: 	{TwelveDaysTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(TwelveDaysTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	5
		each: 	TwelveDaysTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. TwelveDaysTest}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves)
		testSelector: 	#test02_VerseSecondDayTwoTurtleDoves
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
		runTestCases: 	{TwelveDaysTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
		runTestCases: 	{TwelveDaysTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves))
		runTestCases: 	{TwelveDaysTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test02_VerseSecondDayTwoTurtleDoves...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
TwelveDaysTest(TestAsserter)>>assert:description:resumable:
TwelveDaysTest(TestAsserter)>>assert:description:
TwelveDaysTest(TestAsserter)>>assert:equals:
TwelveDaysTest>>test02_VerseSecondDayTwoTurtleDoves
TwelveDaysTest(TestCase)>>performTest
[self setUp.
	self performTest] in TwelveDaysTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
TwelveDaysTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in TwelveDaysTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
TwelveDaysTest(TestCase)>>debug
TwelveDaysTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#Grains is missing, and does not understand #new
31 May 2023 8:24:28.103629 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(Grains)
		aMessage: 	new
		exception: 	#Grains is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

GrainsTest>>setUp
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	nil
		grainsCalculator: 	nil


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	nil
		grainsCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	nil
		grainsCalculator: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	nil
		grainsCalculator: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	nil


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
GrainsTest>>setUp
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#Grains is missing, and does not understand #new
31 May 2023 8:24:28.207119 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject>>doesNotUnderstand: #new
	Receiver: nil
	Arguments and temporary variables: 
		node: 	RBVariableNode(Grains)
		aMessage: 	new
		exception: 	#Grains is missing, and does not understand #new
		resumeValue: 	nil
	Receiver's instance variables: 
nil

GrainsTest>>setUp
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	nil


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	nil


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	nil


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	nil


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)


CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation



--- The full stack ---
UndefinedObject>>doesNotUnderstand: #new
GrainsTest>>setUp
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #atSquare:
31 May 2023 8:24:33.79506 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #atSquare:
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	atSquare: 1
		exception: 	Instance of Grains did not understand #atSquare:
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

GrainsTest>>test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
Grains(Object)>>doesNotUnderstand: #atSquare:
GrainsTest>>test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #atSquare:
31 May 2023 8:24:33.887865 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #atSquare:
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	atSquare: 1
		exception: 	Instance of Grains did not understand #atSquare:
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

GrainsTest>>test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
Grains(Object)>>doesNotUnderstand: #atSquare:
GrainsTest>>test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 2 instead of 1.
31 May 2023 8:26:49.669979 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got 2 instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:equals:
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		actual: 	2
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest>>test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	2
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>assert:equals:
GrainsTest>>test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 2 instead of 1.
31 May 2023 8:26:49.774792 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got 2 instead of 1.'
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:equals:
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		actual: 	2
		expected: 	1
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest>>test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	2
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:24:28.009544-04:00
		failures: 	a Set(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		errors: 	an OrderedCollection(GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheS...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Arguments and temporary variables: 
		result: 	3 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 2 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set() #tim...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
		testSelector: 	#test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSquareAt1))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test01_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>assert:equals:
GrainsTest>>test01_ReturnsTheNumberOfGrainsOnTheSquareAt1
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Should get an error with the correct description
31 May 2023 8:27:22.815645 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBlock: 	[grainsCalculator atSquare: 0]
		anExceptionalEvent: 	Error
		substring: 	'square must be between 1 and 64'
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:27:22.786494-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:27:22.786494-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Rais...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Should get an error with the correct description
31 May 2023 8:27:22.896954 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBlock: 	[grainsCalculator atSquare: 0]
		anExceptionalEvent: 	Error
		substring: 	'square must be between 1 and 64'
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:27:22.786494-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:27:22.786494-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Rais...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Should get an error with the correct description
31 May 2023 8:30:03.17185 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBlock: 	[grainsCalculator atSquare: 0]
		anExceptionalEvent: 	Error
		substring: 	'square must be between 1 and 64'
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:30:03.097742-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:30:03.097742-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Rais...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Should get an error with the correct description
31 May 2023 8:30:03.237773 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBlock: 	[grainsCalculator atSquare: 0]
		anExceptionalEvent: 	Error
		substring: 	'square must be between 1 and 64'
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:30:03.097742-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:30:03.097742-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Rais...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Should get an error with the correct description
31 May 2023 8:32:24.731113 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBlock: 	[grainsCalculator atSquare: 0]
		anExceptionalEvent: 	Error
		substring: 	'square must be between 1 and 64'
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:32:24.701949-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:32:24.701949-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Rais...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Should get an error with the correct description
31 May 2023 8:32:24.805574 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBlock: 	[grainsCalculator atSquare: 0]
		anExceptionalEvent: 	Error
		substring: 	'square must be between 1 and 64'
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:32:24.701949-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:32:24.701949-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Rais...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Should get an error with the correct description
31 May 2023 8:33:35.197531 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBlock: 	[grainsCalculator atSquare: 0]
		anExceptionalEvent: 	Error
		substring: 	'square must be between 1 and 64'
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:33:35.156692-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:33:35.156692-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Rais...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Should get an error with the correct description
31 May 2023 8:33:35.281211 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		aBlock: 	[grainsCalculator atSquare: 0]
		anExceptionalEvent: 	Error
		substring: 	'square must be between 1 and 64'
		aString: 	'Should get an error with the correct description'
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:33:35.156692-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Raises...etc...
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:33:35.156692-04:00
		failures: 	a Set(GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0R...etc...
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesA...etc...


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0...etc...
		testSelector: 	#test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExcepti...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0Rais...etc...
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnExce...etc...

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTheSqu...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test08_ReturnsTheNumberOfGrainsOnTh...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>should:raise:whoseDescriptionIncludes:description:
GrainsTest>>test08_ReturnsTheNumberOfGrainsOnTheSquareSquare0RaisesAnException
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Error did not understand #describes:
31 May 2023 8:34:07.715049 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Error(Object)>>doesNotUnderstand: #describes:
	Receiver: Error
	Arguments and temporary variables: 
		aMessage: 	describes: 'square must be between 1 and 64'
		exception: 	Instance of Error did not understand #describes:
		resumeValue: 	nil
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	nil
		signalContext: 	nil
		handlerContext: 	nil
		outerContext: 	nil


Grains>>atSquare:
	Receiver: a Grains
	Arguments and temporary variables: 
		square: 	0
	Receiver's instance variables: 
a Grains

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Grains new atSquare: 0
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Grains new atSquare: 0
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Grains new atSquare: 0'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 22) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Grains new atSquare: 0' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Grains new atSquare: 0'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 22) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Grains new atSquare: 0' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(129241088))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(129241088)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		event: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		evt: 	[(22.0@21.0) mouseUp 7380622 nil]
		all: 	an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(11001446...etc...
		m: 	a SpToolbarButtonMorph(129241088)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(110014464) a SpToolbarBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(110014464) a SpToolbarBu...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		evt: 	[(22.0@21.0) mouseUp 7380622 nil]
		all: 	an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(11001446...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(22.0@21.0) mouseUp 7380622 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(129241088)
	Receiver's instance variables: 
		timeStamp: 	7380622
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(22.0@21.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(529@248.0) corner: (545@264.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@248.0) corner: (545@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@248) mouseUp 7380622 nil]
		targetOffset: 	(22.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(1015088640)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(529@248.0) corner: (545@264.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@248.0) corner: (545@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@248) mouseUp 7380622 nil]
		targetOffset: 	(22.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(529@248.0) corner: (545@264.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@248.0) corner: (545@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@248) mouseUp 7380622 nil]
		targetOffset: 	(22.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(529@248.0) corner: (545@264.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@248.0) corner: (545@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@248) mouseUp 7380622 nil]
		targetOffset: 	(22.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		evt: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(529@248.0) corner: (545@264.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@248.0) corner: (545@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@248) mouseUp 7380622 nil]
		targetOffset: 	(22.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	7368907
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(32364544)))
		lastAlarmTime: 	7380601
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	7368907
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(32364544)))
		lastAlarmTime: 	7380601
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph



--- The full stack ---
Error(Object)>>doesNotUnderstand: #describes:
Grains>>atSquare:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Error did not understand #describes:
31 May 2023 8:34:07.836328 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Error(Object)>>doesNotUnderstand: #describes:
	Receiver: Error
	Arguments and temporary variables: 
		aMessage: 	describes: 'square must be between 1 and 64'
		exception: 	Instance of Error did not understand #describes:
		resumeValue: 	nil
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	nil
		signalContext: 	nil
		handlerContext: 	nil
		outerContext: 	nil


Grains>>atSquare:
	Receiver: a Grains
	Arguments and temporary variables: 
		square: 	0
	Receiver's instance variables: 
a Grains

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Grains new atSquare: 0
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Grains new atSquare: 0
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Grains new atSquare: 0'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 22) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Grains new atSquare: 0' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Grains new atSquare: 0'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 22) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Grains new atSquare: 0' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(129241088))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(129241088)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		event: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		evt: 	[(22.0@21.0) mouseUp 7380622 nil]
		all: 	an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(11001446...etc...
		m: 	a SpToolbarButtonMorph(129241088)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(110014464) a SpToolbarBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(110014464) a SpToolbarBu...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		evt: 	[(22.0@21.0) mouseUp 7380622 nil]
		all: 	an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(11001446...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(22.0@21.0) mouseUp 7380622 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(129241088)
	Receiver's instance variables: 
		timeStamp: 	7380622
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(22.0@21.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	nil
		color: 	(Color r: 0.9012707722385142 g: 0.9012707722385142 b: 0.9012707722385142...etc...
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(529@248.0) corner: (545@264.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@248.0) corner: (545@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@248) mouseUp 7380622 nil]
		targetOffset: 	(22.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(1015088640)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(529@248.0) corner: (545@264.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@248.0) corner: (545@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@248) mouseUp 7380622 nil]
		targetOffset: 	(22.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(529@248.0) corner: (545@264.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@248.0) corner: (545@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@248) mouseUp 7380622 nil]
		targetOffset: 	(22.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(529@248.0) corner: (545@264.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@248.0) corner: (545@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@248) mouseUp 7380622 nil]
		targetOffset: 	(22.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		evt: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(529@248.0) corner: (545@264.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(529@248.0) corner: (545@264.0)
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(529@248) mouseUp 7380622 nil]
		targetOffset: 	(22.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	7368907
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(32364544)))
		lastAlarmTime: 	7380601
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	7368907
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(32364544)))
		lastAlarmTime: 	7380601
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	(0@0) corner: (1354@705)
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph



--- The full stack ---
Error(Object)>>doesNotUnderstand: #describes:
Grains>>atSquare:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: square must be between 1 and 64
31 May 2023 8:34:36.117426 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains>>atSquare:
	Receiver: a Grains
	Arguments and temporary variables: 
		square: 	0
	Receiver's instance variables: 
a Grains

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Grains new atSquare: 0
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Grains new atSquare: 0
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Grains new atSquare: 0'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 22) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Grains new atSquare: 0' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Grains new atSquare: 0'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 22) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Grains new atSquare: 0' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(129241088))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(129241088)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		event: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		evt: 	[(22.0@21.0) mouseUp 7380622 nil]
		all: 	an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(11001446...etc...
		m: 	a SpToolbarButtonMorph(129241088)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(110014464) a SpToolbarBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(110014464) a SpToolbarBu...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		evt: 	[(22.0@21.0) mouseUp 7380622 nil]
		all: 	an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(11001446...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(22.0@21.0) mouseUp 7380622 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(129241088)
	Receiver's instance variables: 
		timeStamp: 	7380622
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(22.0@21.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388@192.0) corner: (404@208.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(388@192) mouseUp 7409081 nil]
		targetOffset: 	(29.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(1015088640)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(388@192.0) corner: (404@208.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(388@192) mouseUp 7409081 nil]
		targetOffset: 	(29.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388@192.0) corner: (404@208.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(388@192) mouseUp 7409081 nil]
		targetOffset: 	(29.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(388@192.0) corner: (404@208.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(388@192) mouseUp 7409081 nil]
		targetOffset: 	(29.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		evt: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(388@192.0) corner: (404@208.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(388@192) mouseUp 7409081 nil]
		targetOffset: 	(29.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	7368907
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(384024576)) MorphicAlarm(#...etc...
		lastAlarmTime: 	7409060
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	7368907
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(384024576)) MorphicAlarm(#...etc...
		lastAlarmTime: 	7409060
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
Grains>>atSquare:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: square must be between 1 and 64
31 May 2023 8:34:36.202096 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains>>atSquare:
	Receiver: a Grains
	Arguments and temporary variables: 
		square: 	0
	Receiver's instance variables: 
a Grains

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Grains new atSquare: 0
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Grains new atSquare: 0
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Grains new atSquare: 0'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 22) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Grains new atSquare: 0' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Grains new atSquare: 0'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 22) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ 'Grains new atSquare: 0' ]
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(129241088))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(129241088)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		event: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		evt: 	[(22.0@21.0) mouseUp 7380622 nil]
		all: 	an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(11001446...etc...
		m: 	a SpToolbarButtonMorph(129241088)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(110014464) a SpToolbarBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(110014464) a SpToolbarBu...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		evt: 	[(22.0@21.0) mouseUp 7380622 nil]
		all: 	an Array(a SpToolbarButtonMorph(129241088) a SpToolbarButtonMorph(11001446...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(22.0@21.0) mouseUp 7380622 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(129241088)
	Receiver's instance variables: 
		timeStamp: 	7380622
		source: 	a HandMorph(1015088640)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(22.0@21.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(129241088)
	Arguments and temporary variables: 
		anEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(344855552)
		submorphs: 	an Array(an AlignmentMorph(1051686912))
		fullBounds: 	(0@5) corner: (45@39)
		color: 	Color transparent
		extension: 	a MorphExtension (868448768) [balloonText]  [other:  (presenter -> a...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(648519168)'Do it'
		iconMorph: 	an ImageMorph(735120384)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388@192.0) corner: (404@208.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(388@192) mouseUp 7409081 nil]
		targetOffset: 	(29.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(1015088640)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(22.0@21.0) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(388@192.0) corner: (404@208.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(388@192) mouseUp 7409081 nil]
		targetOffset: 	(29.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		focusHolder: 	a SpToolbarButtonMorph(129241088)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(388@192.0) corner: (404@208.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(388@192) mouseUp 7409081 nil]
		targetOffset: 	(29.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(388@192.0) corner: (404@208.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(388@192) mouseUp 7409081 nil]
		targetOffset: 	(29.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(1015088640)
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
		evt: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		bounds: 	(388@192.0) corner: (404@208.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (309614592)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(653452800)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(388@192) mouseUp 7409081 nil]
		targetOffset: 	(29.0@16.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(529@248) mouseUp 7380622 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	7368907
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(384024576)) MorphicAlarm(#...etc...
		lastAlarmTime: 	7409060
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(1015088640))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	7368907
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(384024576)) MorphicAlarm(#...etc...
		lastAlarmTime: 	7409060
		activeHand: 	a HandMorph(1015088640)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1354@705)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1354@705)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(51999232) a TaskbarMorph(827411968) a SpWind...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.9403714565004888 g: 0.9403714565004888 b: 0.9403714565004888...etc...
		extension: 	a MorphExtension (51503104) [other:  (dragEnabled -> true) (dropEnab...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'



--- The full stack ---
Grains>>atSquare:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #total
31 May 2023 8:34:49.761195 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #total
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	total
		exception: 	Instance of Grains did not understand #total
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:34:49.736159-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:34:49.736159-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrain...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
Grains(Object)>>doesNotUnderstand: #total
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #total
31 May 2023 8:34:49.849858 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #total
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	total
		exception: 	Instance of Grains did not understand #total
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:34:49.736159-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:34:49.736159-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrain...etc...
		metaLevelScope: 	ClyInstanceSideScope


[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
	Receiver: a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		command: 	a ClyRunTestsFromMethodsCommand
		context: 	a ClyFullBrowserMethodContext
		activationStrategy: 	a ClyTableIconCommandActivation


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCo...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :exc | self processCommandFailure: exc ]
	Receiver's instance variables: 
		outerContext: 	CmdCommandActivator>>executeCommand
		startpc: 	a CompiledBlock: [self prepareCommandForExecution.
	context executeCom...etc...
		numArgs: 	0
		receiver: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)



--- The full stack ---
Grains(Object)>>doesNotUnderstand: #total
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #adaptToNumber:andSend:
31 May 2023 8:36:57.02155 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	adaptToNumber: 0 andSend: #+
		exception: 	Instance of Grains did not understand #adaptToNumber:andSend:
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

Grains(Object)>>adaptToInteger:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		rcvr: 	0
		selector: 	#+
	Receiver's instance variables: 
a Grains

SmallInteger(Integer)>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

SmallInteger>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

Grains>>total
	Receiver: a Grains
	Arguments and temporary variables: 
		result: 	0
		square: 	1
	Receiver's instance variables: 
a Grains

GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:34:49.736159-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:34:49.736159-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))


--- The full stack ---
Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
Grains(Object)>>adaptToInteger:andSend:
SmallInteger(Integer)>>+
SmallInteger>>+
Grains>>total
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #adaptToNumber:andSend:
31 May 2023 8:36:57.105594 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	adaptToNumber: 0 andSend: #+
		exception: 	Instance of Grains did not understand #adaptToNumber:andSend:
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

Grains(Object)>>adaptToInteger:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		rcvr: 	0
		selector: 	#+
	Receiver's instance variables: 
a Grains

SmallInteger(Integer)>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

SmallInteger>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

Grains>>total
	Receiver: a Grains
	Arguments and temporary variables: 
		result: 	0
		square: 	1
	Receiver's instance variables: 
a Grains

GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:34:49.736159-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors...etc...


TestResult>>runCaseForDebug:
	Receiver: 2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, 0 passed unexpected...etc...
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:34:49.736159-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	2 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 2 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))


--- The full stack ---
Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
Grains(Object)>>adaptToInteger:andSend:
SmallInteger(Integer)>>+
SmallInteger>>+
Grains>>total
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #adaptToNumber:andSend:
31 May 2023 8:37:59.09397 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	adaptToNumber: 0 andSend: #+
		exception: 	Instance of Grains did not understand #adaptToNumber:andSend:
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

Grains(Object)>>adaptToInteger:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		rcvr: 	0
		selector: 	#+
	Receiver's instance variables: 
a Grains

SmallInteger(Integer)>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

SmallInteger>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

Grains>>total
	Receiver: a Grains
	Arguments and temporary variables: 
		result: 	0
		square: 	1
	Receiver's instance variables: 
a Grains

GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:37:59.067788-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:37:59.067788-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))


--- The full stack ---
Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
Grains(Object)>>adaptToInteger:andSend:
SmallInteger(Integer)>>+
SmallInteger>>+
Grains>>total
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #adaptToNumber:andSend:
31 May 2023 8:37:59.169385 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	adaptToNumber: 0 andSend: #+
		exception: 	Instance of Grains did not understand #adaptToNumber:andSend:
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

Grains(Object)>>adaptToInteger:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		rcvr: 	0
		selector: 	#+
	Receiver's instance variables: 
a Grains

SmallInteger(Integer)>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

SmallInteger>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

Grains>>total
	Receiver: a Grains
	Arguments and temporary variables: 
		result: 	0
		square: 	1
	Receiver's instance variables: 
a Grains

GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:37:59.067788-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:37:59.067788-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))


--- The full stack ---
Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
Grains(Object)>>adaptToInteger:andSend:
SmallInteger(Integer)>>+
SmallInteger>>+
Grains>>total
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #adaptToNumber:andSend:
31 May 2023 8:38:55.227748 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	adaptToNumber: 0 andSend: #+
		exception: 	Instance of Grains did not understand #adaptToNumber:andSend:
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

Grains(Object)>>adaptToInteger:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		rcvr: 	0
		selector: 	#+
	Receiver's instance variables: 
a Grains

SmallInteger(Integer)>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

SmallInteger>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

Grains>>total
	Receiver: a Grains
	Arguments and temporary variables: 
		result: 	0
		square: 	1
	Receiver's instance variables: 
a Grains

GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:38:55.202381-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:38:55.202381-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))


--- The full stack ---
Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
Grains(Object)>>adaptToInteger:andSend:
SmallInteger(Integer)>>+
SmallInteger>>+
Grains>>total
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #adaptToNumber:andSend:
31 May 2023 8:38:55.295773 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	adaptToNumber: 0 andSend: #+
		exception: 	Instance of Grains did not understand #adaptToNumber:andSend:
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

Grains(Object)>>adaptToInteger:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		rcvr: 	0
		selector: 	#+
	Receiver's instance variables: 
a Grains

SmallInteger(Integer)>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

SmallInteger>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

Grains>>total
	Receiver: a Grains
	Arguments and temporary variables: 
		result: 	0
		square: 	1
	Receiver's instance variables: 
a Grains

GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:38:55.202381-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:38:55.202381-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))


--- The full stack ---
Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
Grains(Object)>>adaptToInteger:andSend:
SmallInteger(Integer)>>+
SmallInteger>>+
Grains>>total
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 0 instead of 18446744073709551615.
31 May 2023 8:40:34.054491 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got 0 instead of 18446744073709551615.'
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:equals:
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		actual: 	0
		expected: 	18446744073709551615
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	0
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:40:33.991157-04:00
		failures: 	a Set(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:40:33.991157-04:00
		failures: 	a Set(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#test11_ReturnsTheTotal...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrain...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>assert:equals:
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 0 instead of 18446744073709551615.
31 May 2023 8:40:34.138105 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

GrainsTest(TestAsserter)>>assert:description:resumable:
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
		resumableBoolean: 	false
		exception: 	TestFailure
		aString: 	'Got 0 instead of 18446744073709551615.'
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:description:
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[self comparingStringBetween: actual and: expected]
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestAsserter)>>assert:equals:
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		actual: 	0
		expected: 	18446744073709551615
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	0
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:40:33.991157-04:00
		failures: 	a Set(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:40:33.991157-04:00
		failures: 	a Set(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 1 failure, 0 errors, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#test11_ReturnsTheTotal...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyFullBrowserMethodContext
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowserMorph(394625024)
		selectedItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrain...etc...
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
GrainsTest(TestAsserter)>>assert:description:resumable:
GrainsTest(TestAsserter)>>assert:description:
GrainsTest(TestAsserter)>>assert:equals:
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #adaptToNumber:andSend:
31 May 2023 8:41:47.492143 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	adaptToNumber: 0 andSend: #+
		exception: 	Instance of Grains did not understand #adaptToNumber:andSend:
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

Grains(Object)>>adaptToInteger:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		rcvr: 	0
		selector: 	#+
	Receiver's instance variables: 
a Grains

SmallInteger(Integer)>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

SmallInteger>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

Grains>>total
	Receiver: a Grains
	Arguments and temporary variables: 
		result: 	0
		square: 	1
	Receiver's instance variables: 
a Grains

GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	nil
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:41:47.46965-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:41:47.46965-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))


--- The full stack ---
Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
Grains(Object)>>adaptToInteger:andSend:
SmallInteger(Integer)>>+
SmallInteger>>+
Grains>>total
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grains did not understand #adaptToNumber:andSend:
31 May 2023 8:41:47.570199 pm

VM: unix - x86_64 - linux-gnu - CoInterpreter VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 97a2c5d3-7db4-0d00-9da7-39dc08c6380e Mar 30 2023
v9.0.22 - Commit: 421845e - Date: 2023-03-30 09:49:26 +0200

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		aMessage: 	adaptToNumber: 0 andSend: #+
		exception: 	Instance of Grains did not understand #adaptToNumber:andSend:
		resumeValue: 	nil
	Receiver's instance variables: 
a Grains

Grains(Object)>>adaptToInteger:andSend:
	Receiver: a Grains
	Arguments and temporary variables: 
		rcvr: 	0
		selector: 	#+
	Receiver's instance variables: 
a Grains

SmallInteger(Integer)>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

SmallInteger>>+
	Receiver: 0
	Arguments and temporary variables: 
		aNumber: 	a Grains
	Receiver's instance variables: 
0

Grains>>total
	Receiver: a Grains
	Arguments and temporary variables: 
		result: 	0
		square: 	1
	Receiver's instance variables: 
a Grains

GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	nil
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest(TestCase)>>performTest
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self setUp.
	self performTest]
	Arguments and temporary variables: 
		aBlock: 	[
		self tearDown.
		self cleanUpInstanceVariables]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>runCase
		startpc: 	a CompiledBlock: [self setUp.
	self performTest]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>runCase
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [aTestCase runCase]
	Arguments and temporary variables: 
		aBlock: 	[
			"Terminated test is not considered as completed (user just closed ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[
		[aTestCase runCase] ensure: [
			"Terminated test is not cons...etc...
		startpc: 	a CompiledBlock: [aTestCase runCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user...etc...
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :err | 
			self handleException: err 
	]
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseUnderWatchdog:
		startpc: 	a CompiledBlock: [
		[aTestCase runCase] ensure: [
			"Terminated test...etc...
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCaseUnderWatchdog:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [self runTestCaseUnderWatchdog: aTestCase]
	Arguments and temporary variables: 
		aBlock: 	[
		testCompleted := true.
		watchDogSemaphore signal.  "signal that te...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	a CompiledBlock: [self runTestCaseUnderWatchdog: aTestCase]
		numArgs: 	0
		receiver: 	a TestExecutionEnvironment


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ]
	Arguments and temporary variables: 
		aBlock: 	[
		self value: current.
		anExecutionEnvironment deactivated]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	a CompiledBlock: [ self value: anExecutionEnvironment.
	anExecutionEnv...etc...
		numArgs: 	0
		receiver: 	CurrentExecutionEnvironment


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[
		testEnv runTestCase: aTestCase]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[
		testEnv runTestCase: aTestCase]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [self schedule.
	"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [self schedule.
	"It is critical th...etc...
		testCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		maxTimeForTest: 	0:00:00:10
		testCompleted: 	false
		services: 	an OrderedCollection(a ProcessMonitorTestService)
		mainTestProcess: 	a Process in nil


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


GrainsTest(TestCase)>>runCaseManaged
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:41:47.46965-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTest...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[:ex | ex sunitAnnounce: aTestCase toResult: self. ex pass]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	a CompiledBlock: [
	aTestCase announce: TestCaseStarted withResult: se...etc...
		numArgs: 	0
		receiver: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error,...etc...


TestResult>>runCaseForDebug:
	Receiver: 1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0 passed unexpected
	Arguments and temporary variables: 
		aTestCase: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		timeStamp: 	2023-05-31T20:41:47.46965-04:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsO...etc...
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
			result u...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GrainsTest(TestCase)>>debug
		startpc: 	a CompiledBlock: [ result runCaseForDebug: self ]
		numArgs: 	0
		receiver: 	GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard


GrainsTest(TestCase)>>debug
	Receiver: GrainsTest>>#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Arguments and temporary variables: 
		result: 	1 ran, 0 passed, 0 skipped, 0 expected failures, 0 failures, 1 error, 0...etc...
	Receiver's instance variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		expectedFails: 	#()
		grainsCalculator: 	a Grains


GrainsTest class(TestCase class)>>debug:
	Receiver: GrainsTest
	Arguments and temporary variables: 
		aSymbol: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		superclass: 	ExercismTest
		methodDict: 	a MethodDictionary(#setUp->GrainsTest>>#setUp #test01_ReturnsTheNum...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#GrainsTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Exercise@Grains'
		history: 	a Dictionary(#errors->a Set(#test11_ReturnsTheTotalNumberOfGrainsOnThe...etc...
		solutionId: 	'9384c72bb2b3457985ed605c82db475e'


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		testClass: 	GrainsTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
		each: 	GrainsTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(GrainsTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
		self runTest: testSelector of: each ]
		index: 	4
		each: 	GrainsTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. GrainsTest. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
		testSelector: 	#test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnT...etc...
		runTestCases: 	{GrainsTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))
	Arguments and temporary variables: 
		aBlock: 	[:each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(test11_ReturnsTheTotalNumberOfGrainsOnTheBoard))


--- The full stack ---
Grains(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
Grains(Object)>>adaptToInteger:andSend:
SmallInteger(Integer)>>+
SmallInteger>>+
Grains>>total
GrainsTest>>test11_ReturnsTheTotalNumberOfGrainsOnTheBoard
GrainsTest(TestCase)>>performTest
[self setUp.
	self performTest] in GrainsTest(TestCase)>>runCase
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>runCase
[aTestCase runCase] in [
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>ensure:
[
		[aTestCase runCase] ensure: [
			"Terminated test is not considered as completed (user just closed a debugger for example)"
			mainTestProcess isTerminating ifFalse: [ 
				self handleCompletedTest ]]
	] in TestExecutionEnvironment>>runTestCaseUnderWatchdog:
FullBlockClosure(BlockClosure)>>on:do:
TestExecutionEnvironment>>runTestCaseUnderWatchdog:
[self runTestCaseUnderWatchdog: aTestCase] in TestExecutionEnvironment>>runTestCase:
FullBlockClosure(BlockClosure)>>ensure:
TestExecutionEnvironment>>runTestCase:
[
		testEnv runTestCase: aTestCase] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
	anExecutionEnvironment activated.
	aBlock value  ] in CurrentExecutionEnvironment class>>activate:for:
FullBlockClosure(BlockClosure)>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GrainsTest(TestCase)>>runCaseManaged
[
	aTestCase announce: TestCaseStarted withResult: self.
	aTestCase runCaseManaged.
	aTestCase announce: TestCaseEnded  withResult: self.
	"To not affect performance of big test suites following logic is not inside addPass: method"
	errors remove: aTestCase ifAbsent: [].
	failures remove: aTestCase ifAbsent: [].
	self addPass: aTestCase] in TestResult>>runCaseForDebug:
FullBlockClosure(BlockClosure)>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GrainsTest(TestCase)>>debug
FullBlockClosure(BlockClosure)>>ensure:
GrainsTest(TestCase)>>debug
GrainsTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | 
		self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[:each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyRunTestsFromMethodsCommand>>execute
ClyFullBrowserMethodContext(ClySystemBrowserContext)>>executeCommand:by:
[self prepareCommandForExecution.
	context executeCommand: command by: self.
	self applyCommandResult] in CmdCommandActivator>>executeCommand
FullBlockClosure(BlockClosure)>>on:do:
CmdCommandActivator>>executeCommand
[target perform: actionSelector withArguments: arguments] in IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
FullBlockClosure(BlockClosure)>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButtonMorph(SimpleButtonMorph)>>doButtonAction
IconicButtonMorph(SimpleButtonMorph)>>mouseUp:
IconicButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButtonMorph(Morph)>>handleEvent:
IconicButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

